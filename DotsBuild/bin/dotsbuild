#!@perl@
use strict;

use lib "$ENV{GUS_HOME}/lib/perl";
use GUS::Pipeline::Manager;
use GUS::Pipeline::MakeTaskDirs;
use CBIL::Util::PropertySet;
use File::Basename;

$| = 1;
umask 002;


my $propertiesFile = $ARGV[0];

&usage unless -e $propertiesFile;

# [name, default (or null if reqd), comment]
my @properties = 
(
 # properties required by Pipeline API
 ["liniacServer",         "",  "full name of liniac server"],
 ["stopBefore",   "none",  "the step to stop before.  uses the signal name"],

 # properties used by dotsbuild
 ["dotsBuildDir",         "",  "local dots update dir"],
 ["dotsRelease",          "",  "eg 5 or 6"],
 ["completedSpeciesNickName", "",  "nick name of the other species (eg mus if this is a hum build) if that one completed first. use 'notdone' if it isn't done."],
 ["reassemble",           "",  "yes or no"],
 ["serverPath",           "",  "full path of dots update dir on liniac server"],
 ["nodePath",             "",  "full path of scratch dir on liniac node"],
 ["repeatmask.taskSize",  "",  "number of seqs to process per repeatmask subtask"],
 ["repeatmask.path",      "",  "path on node of repeatmask executable"],
 ["repeatmask.options",   "",  "number of seqs to process per blastmatrix subtask"],
 ["blastmatrix.taskSize", "",  "number of seqs to process per blastmatrix subtask"],
 ["blastsimilarity.taskSize", "",  "number of seqs to process per blastsimilarity subtask"],
 ["blastsimilarity.Bparam", "", "paramter B for blastsimilarity"], 
 ["blastsimilarity.Vparam", "", "paramter V for blastsimilarity"],
 ["blastsimilarity.Eparam", "", "paramter E for blastsimilarity"],
 ["wuBlastBinPath",         "",  "path of wu blast bin dir (local)"],
 ["wuBlastBinPathLiniac",         "",  "path of wu blast bin dir on Liniac"],
 ["ncbiBlastBinPathLiniac",         "",  "path of ncbi blast bin dir on Liniac"],
 ["taxonId",              "",  "eg 14 for mus"],
 ["speciesFullname",              "",  "eg Home sapiens"],
 ["speciesNickname",              "",  "eg mus, hum"],
 ["gusConfigFile",           "",  ""],
 ["initialCluster.length",          "",  "length cutoff"],
 ["initialCluster.percent",         "",  "percent ident cutoff"],
 ["initialCluster.logbase",         "",  ""],
 ["initialCluster.consistentEnds",         "",  ""],
 ["initialCluster.cliqueSzArray",   "",  ""],
 ["initialCluster.logbaseArray",    "",  ""],
 ["intermedCluster.length",         "",  "length cutoff"],
 ["intermedCluster.percent",        "",  "percent ident cutoff"],
 ["intermedCluster.logbase",        "",  ""],
 ["intermedCluster.consistentEnds",         "",  ""],
 ["intermedCluster.cliqueSzArray",  "",  ""],
 ["intermedCluster.logbaseArray",   "",  ""],
 ["geneCluster.length",         "",  "length cutoff"],
 ["geneCluster.percent",        "",  "percent ident cutoff"],
 ["geneCluster.logbase",        "",  ""],
 ["geneCluster.consistentEnds",         "",  ""],
 ["geneCluster.cliqueSzArray",  "",  ""],
 ["geneCluster.logbaseArray",   "",  ""],
 ["downloadGenbank",   "",  "yes or no"],
 ["downloadTaxon",   "",  "yes or no"],
 ["downloadNRDB",   "",  "yes or no"],
 ["loadDbEst", "", "yes or no"],
 ["loadGeneCards",   "",  "yes or no"],
 ["downloadCDD",   "",  "yes or no"],
 ["downloadProdom",   "",  "yes or no"],
 ["prodomRelease",   "",  "eg 2001.3"],
 ["mgi_db_rls_id",   "",  "database release id for mgi"],
 ["genecards_db_rls_id",   "",  "database release id for genecards"],
 ["prodom_db_rls_id",   "",  "a new id for the external_database_release table"],
 ["load_db_rls_id",   "",  "a new id for the external_database_release table"],
 ["pfam_db_rls_id",   "",  "a new id for the external_database_release table"],
 ["smart_db_rls_id",   "",  "a new id for the external_database_release table"],
 ["cog_db_rls_id", "","a new id,COG of CDD,for the external_database_release table"],
 ["cd_db_rls_id", "","a new id, CD of CDD, for the external_database_release table"],
 ["nrdb_db_rls_id" , "","the external_database_release_id for nrdb"],
 ["genome_db_rls_id", "","the external_database_release_id for the human genome for this species"],
 ["ucgt_db_rls_id", "","the external_database_release_id for the UC gene tag db"],
 ["ggtc_db_rls_id", "","the external_database_release_id for the GGTC"],
 ["imclone_db_rls_id" , "","the external_database_release_id for imclone"],
 ["locuslink_db_rls_id" , "","the external_database_release_id for LL"],
 ["gea_db_rls_id" , "","the external_database_release_id for GEA"],
 ["makeNewGORules",   "",  "yes or no. Regenerate the GO rules from scratch"],
 ["GOversion",   "",  "version of GO, eg, 2.155"],
 ["GOrootId",   "",  "only until GUS 3.0, eg, 59235"],
 ["ePCRinPath",   "", "where to find e-PCR, eg /usr/local/src/bio/e-PCR/src"],
 ["buildDate" ,   "", "approximate start date of build"],
 ["wordfile" ,   "", "file of word probabilities for framefinder"],
 ["frameFinderRestart" ,  "","list of algorithm_invocation_id for restart of FrameFinder plugin, eg '1,2,3'"],
 ["frameFinderDir" ,  "","directory in which to find the framefinder program"],
 ["NewGeneTags", "", "yes or no"],
 ["dianaDir" ,  "","directory in which to find the diana program"],
 ["userId" ,  "","database user_id from UserInfo table in GUS"],
 ["iPSRestart_finalDots-nrdb" , "","list of algorithm_invocation_id for restart of insertProteinSimilaritiesPK for nrdb, see ffRestart"],
 ["iPSRestart_finalDots-prodom" , "","list of algorithm_invocation_id for restart of insertProteinSimilaritiesPK for prodom, see ffRestart"],
 ["iPSRestart_finalDots-cdd" , "","list of algorithm_invocation_id for restart of insertProteinSimilaritiesPK for cdd, see ffRestart"],
 ["assignDescriptionRestart" , "","list of algorithm_invocation_id for restart of AssignSequenceDescription"],
 ["loadMGI" ,  "",  "yes or no"],
 ["loadGEA" ,  "",  "yes or no"],
 ["insertTaxonRestart" , "","last ncbi_tax_id in the log for restarting LoadTaxon.pm"],
 ["nrdbRestart" , "","last set number in log for restarting LoadNrdb.pm"],
 ["tempLogin" , "","login for temp table space, e.g. pinney\@gusdev"],
 ["tempPassword" , "","password for temp table space"],
 ["loadGeneTrapAssembly", "", "yes or no"],
 ["geneTrapDbRls", "", "name:external_database_release_id abbreviation pairs for gene trap sequences e.g. stl:3692,ggtc:5393"],
 ["loadLocusLink", "", "yes or no"],
 ["projectLinkRestart", "", "yes or no"],
 ["allgenesVersion", "", "version number for allgenes, e.g. 5.0"],
 ["externalDbDir", "", "directory for download data from external databases"],
 ["genbankRel", "", "GenBank release number found in the README file"],
 ["gb_db_rel_id", "", "external_database_release_id for GenBank"],
 ["gbFiles", "", "list of comma delinieated genbank files to be parsed into GUS"],
 ["fileOfRepeats", "","subdirectory and library(file) of repeats, e.g. unknown_release/vector_humMitoRibo.lib"],
 ["refseqRel", "","RefSeq release, e.g 2001-01-08"],
 ["refseq_rel_id", "","external_database_release_id for the RefSeq release"],
 ["refseqFile", "","RefSeq file. e.g. mouse.gbff.gz"],
 ["dbESTRestart", "","number (dbest_id_est from dots.est) to restart parsedbEST plugin on, get from log"],
 ["phrapDir", "","phrap directory"],
 ["dbi_str", "", "string used to identify server and login for LoadNRDB temp table"],
 ["sourceDB", "", "pair list of ExternalDatabase.name:ncbi abreviations for nrdb, e.g. GENBANK (NRDB):gb,EMBL DATA LIBRARY (NRDB):emb"],
 ["proteinDir", "","directory containing protein sequence files"],
 ["project_id", "","project_id from projectinfo table, used in projectLink table,get from first species run"],["makeStatPage", "","make Statistics page, yes or no"],
 ["mgiFiles","","mgi mapping files, a comma delimited list"],
 ["gea_db_rls_id", "","gea external_database_release_id"],
 ["geaFile", "","input file with <gea><LocusLink><accession>"],
 ["gea_db_id", "","gea external_database_id"],
 ["downloadLocusLink", "","download the loc2acc file for LocusLink, yes or no"],
 ["ncbiTaxId", "","ncbi tax_id corresponding to the taxon_id"],
 ["ll_db_id", "","LocusLink external_database_id"],
 ["llDeleteDbRef", "","option to delete dbref entries, used in InsertDbRefAndDbRefNASequence, yes or no"],
 ["allgenesLogin", "","login for allgenes schema, for creation and filling of table ProteinAssembly"],
 ["allgenesPassword", "","password for allgenes schema, for creation and filling of table ProteinAssembly"],
 ["makeAllgenesTable", "","make table ProteinAssembl, yes or no"],
 ["qualityStartDate", "","date when the last SetAssSeqQualStartStop.pm was run for this taxon"],
 ["cddDate", "","approx date for cdd download"],
 ["nrdbDate", "","approx date of NRDB file"],
 ["dbestDate", "","approx date for dbEST files"],
 ["prodomVersion", "","prodom version used for build"],
 ["cddFileDates", "","approx date for cdd files"],
 ["repeatmask.dangleMax", "","option for trimDangling in repeatMasker"],
 ["allgenesSchema", "","login used for allgenes tables schema"],
 ["runQualityStart", "","yes or no"],
 ["otherSpeciesRelease", "","most recent, completed, release number of other the species, hum or mus"],
 ["epconDB_anatomy_ids", "","anatomyids used in query to create EPConDB input seqs file"],
 ["epconDB_array", "","array id used in query to create EPConDB input seqs for array file"],
 ["epconDB_chip", "","chip name used in query to create EPConDB input seqs for array file"],
 ["epconDB_makefile", "","make file of input seqs for EPConDB array, yes or no"],
 ["nrdb_maketemp", "","use --maketemp option for LoadNrdb plugin, yes or no"],
 ["nrdb_delete", "","use --delete option for LoadNrdb plugin, yes or no"],
 ["nrdb_plugin", "","use --plugin option for LoadNrdb plugin, yes or no"]
 ); 

my $propertySet  = CBIL::Util::PropertySet->new($propertiesFile, \@properties);

my $dotsBuildDir = $propertySet->getProp('dotsBuildDir');
my $buildName = &makeBuildName($propertySet->getProp('speciesNickname'));
my $pipelineDir = "$dotsBuildDir/$buildName";


###################  The Pipeline  ##########################

my $mgr = GUS::Pipeline::Manager->new($pipelineDir, $propertySet, $propertiesFile);

&createDotsPipelineDir($propertySet);

&downloadGenbank();

&downloadRefSeq();

##&downloaddbEST(); automatic download and mirror site maintenance planned, sub left in place for now

&downloadTaxon();

&downloadNRDB();

&insertTaxon();

&parseGenbank();

&parseRefSeq();

&parsedbEST();

&extractDots("prev", "'DT.'||");

&makeAssemSeqs();

&extractAssemSeqs();

&copyPipelineDirToLiniac();

&startBlastMatricesOnLiniac(); 

   &qualityStart();
 
   &downloadCDD();

   &downloadProdom();

   &unpackCDD();

   &insertCDD();

   &insertProdom();

   &extractProdom();

   &insertNRDB();

   &extractNRDB();

   &copyProteinDBsToLiniac();

$mgr->waitForLiniac("prevDots and assemSeqs matrices", "waitMatrices");

&copyBlastMatricesFromLiniac();

&cluster("initial", 
  	 "prevDots-prevDots", "assemSeqs-assemSeqs", "prevDots-assemSeqs");

&splitCluster("initial");

&assemble("", $propertySet->getProp('reassemble'), "initial");

&reassemble("initial");

&deleteAssembliesWithNoAssemblySequences("initial");

&extractDots("intermed", "'DT.'||");

&matrix("intermed");

&cluster("intermed", "intermedDots-intermedDots");

&splitCluster("intermed");

&assemble("--assemble_old", "no", "intermed");

&reassemble("intermed");

&deleteAssembliesWithNoAssemblySequences("intermed");

&extractDots("final", "");

&matrix("final");

&markBadSeqs();  

&getIdsPerAssembly(); 

&startSimilaritiesOnLiniac();

   &cluster("gene", "finalDots-finalDots");

   &sortClusters();

   &loadRNAClusters();

   &deleteGenesWithNoRNA();

   &makeFrameFinder();

   &extractMarkers();

   &deleteEPCR();

   &runEPCR();  

   &insertEPCR();

   &deleteAnatomyPercent();

   &insertAnatomyPercent();

   &deleteIndexWords();

   &deleteNRDBIndexWords();

   &deleteMotifIndexWords

   &makeNRDBIndexWordLink();

   &makeMotifIndexWordLink();

   &deleteOldSimilarities();

   &assemblyProteinIntegration();

   &RNAProteinIntegration();

   &makeGeneForRNA();

   &getAssembliesPerGene();

   &makeEpconFastaFiles();

   &prepareEPConBlastSiteFiles();

$mgr->waitForLiniac("protein similarities", "waitProteinSims");

&copySimilaritiesFromLiniac();

&insertProteinSimilarities("finalDots-nrdb", "DoTS::ExternalAASequence");

&insertProteinSimilarities("finalDots-prodom", "DoTS::MotifAASequence");

&substituteCDDPKs();

&insertProteinSimilarities("finalDots-cdd", "DoTS::MotifAASequence");

&assignSequenceDescription();

&makeIndexWords();

&indexSimilarityWords();

&indexNRDBWords();

&getmRNAPerAssembly();

&makePredictedProteinFile();

&makeProteinChunks();

&predictTmAndSignalP();

&parseTMFile();

&parseSGPSignalP();

&parseSGPHMMSignalP();

&deletePredictedAAFeatures("PredictedAAFeature");

&loadTMHMM();

&deletePredictedAAFeatures("SignalPeptideFeature");

&loadSGPSignalP();

&loadSGPHMMSignalP();

&prepareDownloadSiteFiles();      

&prepareBlastSiteFiles(); 

&versionGeneTrapAssembly();

&deleteGeneTrapAssembly();

&insertBaygenomicsGeneTags();

&downloadGGTC();

&makeGGTCFastaFile();

&insertGGTCGeneTags();

&extractGeneTrapTags();

&blastGeneTrapTags();

&loadGeneTrapAssembly();

&downloadMGIInfo();

&deleteMGIToDots();

&loadMGIToDoTS();

&loadMGIInfo();

&deleteGeneCardsToDots();

&parseGeneCardsToDoTS();

&loadGeneCardsToDoTS();

&deleteGEAToDoTS();

&parseGEA();

&loadGEA();

&downloadLocusLink();

&deleteLocusLink();

&parseLocusLink();

&loadLocusLinkToDoTS();

&makeProjectLink(); 

&updateProteinAssemblyTable();

&updateDTOrfPValueTable();

&updateAssemblySignalPSummaryTable();

&updateAssemblyTMDomainSummaryTable();

&updatePromoterRegionTable();

&updatePancreasAssembliesTable();

&createManuallyReviewedDoTSFile();

&createPredTranslDetailsFile();

&makeStatisticsPage();

#&cleanUpFiles();

$mgr->goodbye("Pipeline complete!\n");

#########################   Pipeline Subroutines   ########################

sub createDotsPipelineDir { 
    my ($props) = @_;

    my $dotsBuildDir = $props->getProp('dotsBuildDir');
    my $serverPath = $props->getProp('serverPath');
    my $nodePath = $props->getProp('nodePath');
    my $rmTaskSize = $props->getProp('repeatmask.taskSize');
    my $rmPath = $props->getProp('repeatmask.path');
    my $rmOptions = $props->getProp('repeatmask.options');
    my $dangleMax = $props->getProp('repeatmask.dangleMax');
    my $bmTaskSize = $props->getProp('blastmatrix.taskSize');
    my $bsTaskSize = $props->getProp('blastsimilarity.taskSize');
    my $bsBparam = $props->getProp('blastsimilarity.Bparam');
    my $bsVparam = $props->getProp('blastsimilarity.Vparam');
    my $bsEparam = $props->getProp('blastsimilarity.Eparam');
    my $wuBlastBinPathLiniac = $props->getProp('wuBlastBinPathLiniac');
    my $ncbiBlastBinPathLiniac = $props->getProp('ncbiBlastBinPathLiniac');

    return if (-e "$dotsBuildDir/$buildName/seqfiles");

    $mgr->runCmd("mkdir -p $dotsBuildDir/$buildName/seqfiles");
    $mgr->runCmd("mkdir -p $dotsBuildDir/$buildName/epcr");
    $mgr->runCmd("mkdir -p $dotsBuildDir/$buildName/misc");
    $mgr->runCmd("mkdir -p $dotsBuildDir/$buildName/genetrap");
    $mgr->runCmd("mkdir -p $dotsBuildDir/$buildName/blastSite");
    $mgr->runCmd("mkdir -p $dotsBuildDir/$buildName/downloadSite");
    $mgr->runCmd("mkdir -p $dotsBuildDir/$buildName/cluster/initial");
    $mgr->runCmd("mkdir -p $dotsBuildDir/$buildName/cluster/intermed");
    $mgr->runCmd("mkdir -p $dotsBuildDir/$buildName/cluster/gene");

    &makeRMDir("assemSeqs", $buildName, $dotsBuildDir, 
	       $serverPath, $nodePath, $rmTaskSize, $rmOptions, $dangleMax, $rmPath);
    &makeRMDir("prevDots", $buildName, $dotsBuildDir,
	       $serverPath,  $nodePath, $rmTaskSize, $rmOptions, $dangleMax, $rmPath);
    &makeRMDir("intermedDots", $buildName, $dotsBuildDir,
	       $serverPath,  $nodePath, $rmTaskSize, $rmOptions, $dangleMax, $rmPath);
    &makeRMDir("finalDots", $buildName, $dotsBuildDir,
	       $serverPath,  $nodePath, $rmTaskSize, $rmOptions, $dangleMax, $rmPath);

    &makeMatrixDir("assemSeqs", "assemSeqs", $buildName, $dotsBuildDir, 
		   $serverPath, $nodePath, $bmTaskSize, $wuBlastBinPathLiniac);
    &makeMatrixDir("prevDots", "assemSeqs", $buildName, $dotsBuildDir, 
		   $serverPath, $nodePath, $bmTaskSize, $wuBlastBinPathLiniac);
    &makeMatrixDir("prevDots", "prevDots", $buildName, $dotsBuildDir, 
		   $serverPath, $nodePath, $bmTaskSize, $wuBlastBinPathLiniac);
    &makeMatrixDir("intermedDots", "intermedDots", $buildName, $dotsBuildDir, 
		   $serverPath, $nodePath, $bmTaskSize, $wuBlastBinPathLiniac);
    &makeMatrixDir("finalDots", "finalDots", $buildName, $dotsBuildDir, 
		   $serverPath, $nodePath, $bmTaskSize, $wuBlastBinPathLiniac);

    &makeSimilarityDir("finalDots", "nrdb", $buildName, $dotsBuildDir, 
		       $serverPath, $nodePath, $bsTaskSize, 
		       $wuBlastBinPathLiniac,
		       "nrdb.fsa", '(\d+)', 'blastx', 
		       "-wordmask=seg+xnu W=3 T=1000 B=$bsBparam V=$bsVparam E=$bsEparam");

    &makeSimilarityDir("finalDots", "prodom", $buildName, $dotsBuildDir, 
		       $serverPath, $nodePath, $bsTaskSize, 
		       $wuBlastBinPathLiniac,
		       "prodom.fsa", '(\S+)', 'blastx', 
		       "-wordmask=seg+xnu W=3 T=1000 B=$bsBparam V=$bsVparam E=$bsEparam");
    &makeSimilarityDir("finalDots", "cdd", $buildName, $dotsBuildDir, 
		       $serverPath, $nodePath, $bsTaskSize, 
		       $ncbiBlastBinPathLiniac,
		       "cdd/All",  '\w+\|\w+\|\d+\s+(\w+)', 'rpsblast', 
		       "-a 2 -e .1 -p F");

    &makeAssemblyDir("initial", $buildName, $dotsBuildDir);
    &makeAssemblyDir("intermed", $buildName, $dotsBuildDir);

    $mgr->runCmd("chmod -R g+w $dotsBuildDir/$buildName");
}

sub makeAssemblyDir {
    my ($name, $buildName, $localDir) = @_;

    $mgr->runCmd("mkdir -p $localDir/$buildName/assembly/$name/big");
    $mgr->runCmd("mkdir -p $localDir/$buildName/assembly/$name/small");
}

sub downloadGenbank {
    my $signal = "downloadGenbank";

    return if $mgr->startStep("Downloading Genbank", $signal,'downloadGenbank');

    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $genbankRel = $propertySet->getProp('genbankRel');

    my $downloadSubDir = "$externalDbDir/genbank/$genbankRel";

    my $logfile = "$pipelineDir/logs/downloadGenbank.log";

    $mgr->runCmd("mkdir -p $downloadSubDir");

    my $cmd = "wget -t5 -o $logfile -b -m -np -nd -nH --cut-dirs=1 -R \"gbest*,gbgss*,gbhtg*,gbpat*,gbphg*,gbpln*,gbvrt*,gbvrl*,gbuna*,gbsts*,gbbct*,gbcon*,gbinv*,gbmam*\" -A \"*.seq.gz,README.genbank\"  -P $downloadSubDir ftp://ftp.ncbi.nih.gov/genbank/";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub downloadRefSeq {
    my $signal = "downloadRefSeq";

    return if $mgr->startStep("Downloading RefSeq", $signal,'downloadGenbank');

    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadRefSeq.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');

    my $downloadSubDir = "$externalDbDir/refseq/$date";
    
    $mgr->runCmd("mkdir -p $downloadSubDir");

    my $ftpsite = "ftp://ftp.ncbi.nih.gov/refseq/H_sapiens/mRNA_Prot/";
    my $ftpfile = "hs.gbff.gz";

    my $cmd = "wget -t5 -o $logfile -b -m -np -nd -nH --cut-dirs=3 -A \"$ftpfile\" -P $downloadSubDir $ftpsite";

    $mgr->runCmd($cmd);

    $ftpsite = "ftp://ftp.ncbi.nih.gov/refseq/M_musculus/mRNA_Prot/";
    $ftpfile = "mouse.gbff.gz";

    my $cmd = "wget -t5 -o $logfile -b -m -np -nd -nH --cut-dirs=3 -A \"$ftpfile\" -P $downloadSubDir $ftpsite";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub downloaddbEST {

    my $signal = "downloaddbEST";

    return if $mgr->startStep("Downloading dbEST", $signal,'downloaddbEST');

    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloaddbEST.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');

    my $downloadSubDir = "$externalDbDir/dbest/$date";
    
    $mgr->runCmd("mkdir -p $downloadSubDir");

    my $cmd = "wget -t5 -o $logfile -b -m -np -nd -nH --cut-dirs=3 -P $downloadSubDir  ftp://ftp.ncbi.nih.gov/repository/dbEST/bcp/";

    $mgr->runCmd($cmd);

    $mgr->runCmd("gunzip $downloadSubDir/*.gz");

    $mgr->endStep($signal);
    
}

sub downloadTaxon {
    my $signal = "downloadTaxon";

    return if $mgr->startStep("Downloading Taxon", $signal,'downloadTaxon');

    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadTaxon.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');

    my $downloadSubDir = "$externalDbDir/taxonomy/$date";

    $mgr->runCmd("mkdir -p $downloadSubDir");

    my $cmd = "wget -t5 -o $logfile -b -m -np -nd -nH --cut-dirs=2 -A \"gi_taxid_nucl.dmp.gz,gi_taxid_prot.dmp.gz,taxdump.tar.gz\" -P $downloadSubDir  ftp://ftp.ncbi.nih.gov/pub/taxonomy/"; 

    $mgr->runCmd($cmd);

    $mgr->runCmd("gunzip $downloadSubDir/taxdump.tar.gz");
	
    $mgr->runCmd("tar --extract --file $downloadSubDir/taxdump.tar -C $downloadSubDir");

    $mgr->runCmd("gunzip $downloadSubDir/gi_taxid_nucl.dmp.gz");

    $mgr->runCmd("gunzip $downloadSubDir/gi_taxid_prot.dmp.gz");

    $mgr->endStep($signal);

}

sub downloadNRDB {  

    my $signal = "downloadNRDB";

    return if $mgr->startStep("Downloading NRDB", $signal, 'downloadNRDB');

    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/${signal}.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');

    my $downloadSubDir = "$externalDbDir/nrdb/$date";

    $mgr->runCmd("mkdir -p $downloadSubDir");

    my $cmd = "wget -t5 -b -m -np -nd -nH -o $logfile --cut-dirs=4 -A \"nr.gz\"  -P $downloadSubDir  ftp://ftp.ncbi.nih.gov/blast/db/FASTA/";
	
    $mgr->runCmd($cmd);

    $mgr->runCmd("gunzip $downloadSubDir/nr.gz");

    $mgr->endStep($signal);
}

sub insertTaxon {

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');

    my $downloadSubDir = "$externalDbDir/taxonomy/$date";
    
    my $names = "$downloadSubDir/names.dmp";
    my $nodes = "$downloadSubDir/nodes.dmp";
    my $gencode = "$downloadSubDir/gencode.dmp";
    my $restart = $propertySet->getProp('insertTaxonRestart');
    
    my $args = "--names $names --nodes $nodes --gencode $gencode --restart $restart";
    
    $mgr->runPlugin("loadTaxon", "GUS::Common::Plugin::LoadTaxon", $args,
		    "Loading Taxon tables",'downloadTaxon');
}

sub parseGenbank {

  my $signal = "parseGenBank";

  my $genbankRel = $propertySet->getProp('genbankRel');
  
  my $gb_db_rel_id = $propertySet->getProp('gb_db_rel_id');
  
  my @gbFiles = split (/,/, $propertySet->getProp('gbFiles'));
  
  my $externalDbDir = $propertySet->getProp('externalDbDir');

  
  foreach my $file (@gbFiles) {
    
    my $dirAndFile = "$externalDbDir/genbank/$genbankRel/$file";
    
    my $args = "--gbRel $genbankRel --file $dirAndFile  --db_rel_id $gb_db_rel_id";
    
    my $signal = "gbParse_${file}";
    
    $mgr->runPlugin($signal, "GUS::Common::Plugin::GBParser", $args, "Loading GenBank files into GUS");
    
  }
  foreach my $file (@gbFiles) {

    my $dotsRelease = "release" . $propertySet->getProp('dotsRelease');

    my $buildName = &makeBuildName($propertySet->getProp('speciesNickname'));
    
    my $subDir = "gbParse_".$file;

    my $failFiles = "$dotsBuildDir/$dotsRelease/$buildName/plugins/$subDir/gbparserFailures/*.gb";

    my @fileArr = <$failFiles>;
    
    if ((scalar @fileArr) >= 1) {
      die "There are GenBank entry failures - evaluate and run GBParser manually - then restart dotsbuild\n";
    }
  }

  $mgr->endStep($signal);
  
}

sub parseRefSeq {

  my $signal = "parseRefSeq";

  my $refseqRel = $propertySet->getProp('refseqRel');
  
  my $refseq_rel_id = $propertySet->getProp('refseq_rel_id');
  
  my $refseqFile = $propertySet->getProp('refseqFile');
  
  my $externalDbDir = $propertySet->getProp('externalDbDir');

  my $date = $propertySet->getProp('buildDate');

  my $dirAndFile = "$externalDbDir/refseq/$date/$refseqFile";
    
  my $args = "--gbRel $refseqRel --file $dirAndFile --db_rel_id $refseq_rel_id";
    
  my $signal = "refseq_${refseqFile}";
    
  $mgr->runPlugin($signal, "GUS::Common::Plugin::GBParser", $args, "Loading RefSeq files into GUS");

  my $dotsRelease = "release" . $propertySet->getProp('dotsRelease');

  my $buildName = &makeBuildName($propertySet->getProp('speciesNickname'));

  my $failFiles = "$dotsBuildDir/$dotsRelease/$buildName/plugins/$refseqFile/gbparserFailures/*.gb";
  
  my @fileArr = <$failFiles>;
    
  if ((scalar @fileArr) >= 1) {
    die "There are RefSeq entry failures - evaluate and run GBParser manually - then restart dotsbuild\n";
  }

  $mgr->endStep($signal);

}

sub parsedbEST {

  my $restart = $propertySet->getProp('dbESTRestart');

  my $taxonId = $propertySet->getProp('taxonId');

  my $args = "--log $pipelineDir/logs/dbest.log --fullupdate --span 500 --project 'dbEST Parser' --taxon_id $taxonId --restart_number $restart";
  
  $mgr->runPlugin("loadDbEst", "GUS::Common::Plugin::dbEST", $args, 
		  "Loading dbEST files into GUS", 'loadDbEst');
}

sub makeAssemSeqs {
  
  my $externalDbDir = $propertySet->getProp('externalDbDir');
  
  my $file = $propertySet->getProp('fileOfRepeats');
  
  my $taxonId = $propertySet->getProp('taxonId');
  
  my $repeatFile = "$externalDbDir/repeat/$file";
	
  my $phrapDir = $propertySet->getProp('phrapDir');
    
  my $args = "--taxon_id $taxonId --repeatFile $repeatFile --phrapDir $phrapDir";
  
  $mgr->runPlugin("makeAssemSeqs", 
		  "DoTS::DotsBuild::Plugin::MakeAssemblySequences", $args,
		  "Making assembly table sequences");
}

sub extractAssemSeqs {

    my $taxonId = $propertySet->getProp('taxonId');

    my $outputFile = "$pipelineDir/seqfiles/assemSeqs.fsa"; 
    my $args = "--taxon_id=$taxonId --outputfile $outputFile --extractonly";

    $mgr->runPlugin("extractAssemSeqs", 
		   "DoTS::DotsBuild::Plugin::ExtractAndBlockAssemblySequences",
		    $args, "Extracting assembly table sequences");

}


# $name is prevDots or intermedDots
sub extractDots {
    my ($name, $DTprefix) = @_;

    $name = "${name}Dots";
    my $signal = "${name}Extract";

    return if $mgr->startStep("Extracting $name assemblies from GUS", $signal);

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');
    my $taxonId = $propertySet->getProp('taxonId');
    my $species = $propertySet->getProp('speciesFullname');

    my $seqFile = "$pipelineDir/seqfiles/$name.fsa";
    my $logFile = "$pipelineDir/logs/${name}Extract.log";

    my $sql = "select $DTprefix na_sequence_id,'[$species]',description,'('||number_of_contained_sequences||' sequences)','length='||length,sequence from dots.Assembly where taxon_id = $taxonId";

    my $cmd = "dumpSequencesFromTable.pl --outputFile $seqFile --gusConfigFile $gusConfigFile  --verbose --idSQL \"$sql\" 2>>  $logFile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}


sub copyPipelineDirToLiniac {

    my $nickName = $propertySet->getProp('speciesNickname');
    my $dotsRelease = "release" . $propertySet->getProp('dotsRelease');
    my $serverPath = $propertySet->getProp('serverPath') . "/$dotsRelease";
    my $liniacServer = $propertySet->getProp('liniacServer');
    my $fromDir = "$dotsBuildDir/$dotsRelease";
    my $signal = "dir2liniac";
    return if $mgr->startStep("Copying $dotsBuildDir/$dotsRelease/$nickName to $serverPath on $liniacServer", $signal);

    $mgr->copyToLiniac($fromDir, $nickName, $liniacServer, $serverPath);

    $mgr->endStep($signal);
}

sub startBlastMatricesOnLiniac {

    my $liniacServer = $propertySet->getProp('liniacServer');
    my $serverPath = $propertySet->getProp('serverPath');
    my $signal = "runmatrices";
    return if $mgr->startStep("Starting blast matrices", $signal);
    
    $mgr->endStep($signal);

    my $liniacCmdMsg = "submitPipelineJob runInitialMatrices $serverPath/$buildName NUMBER_OF_NODES";
    my $liniacLogMsg = "monitor $serverPath/$buildName/logs/*.log and xxxxx.xxxx.stdout";

    $mgr->exitToLiniac($liniacCmdMsg, $liniacLogMsg, 1);
}

sub qualityStart {

  my $date = $propertySet->getProp('qualityStartDate');
  my $taxonId = $propertySet->getProp('taxonId');
  my $externalDbDir = $propertySet->getProp('externalDbDir');
  my $file = $propertySet->getProp('fileOfRepeats');
  my $repeatFile = "$externalDbDir/repeat/$file";
  my $phrapDir = $propertySet->getProp('phrapDir');
  
  my $sql = "select a.assembly_sequence_id from dots.assemblysequence a, dotsver.externalnasequencever v where a.na_sequence_id = v.na_sequence_id and v.version_date > $date and v.taxon_id = $taxonId";

  my $args = "--idSQL \"$sql\" --repeatFile $repeatFile --phrapDir $phrapDir";

  $mgr->runPlugin("setQualityStart", 
		   "DoTS::DotsBuild::Plugin::SetAssSeqQualStartStop",
		   $args, "setting quality start in AssemblySequence",'runQualityStart');

}



sub copyBlastMatricesFromLiniac {

    my $serverPath = $propertySet->getProp('serverPath');
    my $liniacServer = $propertySet->getProp('liniacServer');

    my $signal = "matricesFromLiniac";
    return if $mgr->startStep("Copying matrices from $liniacServer", $signal);
    
    $mgr->copyFromLiniac($liniacServer,
                       "$serverPath/$buildName/repeatmask/assemSeqs/master/mainresult",
                       "blocked.err",
                       "$pipelineDir/repeatmask/assemSeqs");

    my @names = ("assemSeqs-assemSeqs", "prevDots-assemSeqs", "prevDots-prevDots");
    foreach my $name (@names) {
	$mgr->copyFromLiniac($liniacServer,
			     "$serverPath/$buildName/matrix/$name/master/mainresult",
			     "blastMatrix.out.gz",
			     "$pipelineDir/matrix/$name");
    }
    
    $mgr->endStep($signal);
}

sub cluster {
    my ($name, @matrices) = @_;

    my $signal = "${name}Cluster";

    return if $mgr->startStep("Clustering $name", $signal);

    my $length = $propertySet->getProp("$signal.length");
    my $percent = $propertySet->getProp("$signal.percent");
    my $logbase = $propertySet->getProp("$signal.logbase");
    my $consistentEnds = $propertySet->getProp("$signal.consistentEnds");
    my $cliqueSzArray = $propertySet->getProp("$signal.cliqueSzArray");
    my $logbaseArray = $propertySet->getProp("$signal.logbaseArray");
    
    my @matrixFileArray;
    foreach my $matrix (@matrices) {
      push(@matrixFileArray,
	   "$pipelineDir/matrix/$matrix/blastMatrix.out.gz");
    }
    my $matrixFiles = join(",", @matrixFileArray); 

    my $ceflag = ($consistentEnds eq "yes")? "--consistentEnds" : "";

    my $outputFile = "$pipelineDir/cluster/$name/cluster.out";
    my $logFile = "$pipelineDir/logs/$signal.log";

    my $cmd = "buildBlastClusters.pl --lengthCutoff $length --percentCutoff $percent --verbose --files '$matrixFiles' --logBase $logbase --iterateCliqueSizeArray $cliqueSzArray $ceflag --iterateLogBaseArray $logbaseArray --sort > $outputFile 2>> $logFile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub splitCluster {
    my ($name) = @_;

    my $signal = "${name}SplitCluster";

    return if $mgr->startStep("SplitCluster $name", $signal);

    my $clusterFile = "$pipelineDir/cluster/$name/cluster.out";
    my $splitCmd = "splitClusterFile $clusterFile";

    $mgr->runCmd($splitCmd);
    $mgr->endStep($signal);
}

sub assemble {
    my ($old, $reassemble, $name) = @_;

    my $signal = "${name}Assemble";

    return if $mgr->startStep("Assemble $name", $signal);

    my $clusterFile = "$pipelineDir/cluster/$name/cluster.out";
    
    &runAssemblePlugin($clusterFile, "big", $name, $old, $reassemble);
    &runAssemblePlugin($clusterFile, "small", $name, $old, $reassemble);
    $mgr->endStep($signal);
    my $msg = 
"EXITING.... PLEASE DO THE FOLLOWING:
 1. check for errors in assemble.errLog and sql failures in updateDOTSAssemblies.log
 2. resume when assembly completes (validly) by re-runnning 'dotsbuild $propertiesFile'
";
    print STDERR $msg;
    print $msg;
    $mgr->goodbye($msg);
}

sub runAssemblePlugin {
    my ($file, $suffix, $name, $assembleOld, $reassemble) = @_;

    my $taxonId = $propertySet->getProp('taxonId');

    my $reass = $reassemble eq "yes"? "--reassemble" : "";
    my $args = "--clusterfile $file.$suffix $assembleOld $reass --taxon_id $taxonId";
    my $pluginCmd = "ga DoTS::DotsBuild::Plugin::UpdateDotsAssembliesWithCap4 --commit $args --comment '$args'";

    my $logfile = "$pipelineDir/logs/${name}Assemble.$suffix.log";
    
    my $assemDir = "$pipelineDir/assembly/$name/$suffix";
    $mgr->runCmd("mkdir -p $assemDir");
    chdir $assemDir || die "Can't chdir to $assemDir";

    my $cmd = "runUpdateAssembliesPlugin --clusterFile $file.$suffix --pluginCmd \"$pluginCmd\" 2>> $logfile"; 
    $mgr->runCmdInBackground($cmd);
}

sub reassemble {
  my ($name) = @_;

  my $signal = "${name}Reassemble";
  
  return if $mgr->startStep("Reassemble $name", $signal);

  my $taxonId = $propertySet->getProp('taxonId');

  my $sql = "select na_sequence_id from dots.assembly where taxon_id = $taxonId  and (assembly_consistency < 90 or length < 50 or length is null or description = 'ERROR: Needs to be reassembled')";

  my $clusterFile = "$pipelineDir/cluster/$name/cluster.out";

  my $suffix = "reassemble";

  my $old = "";

  my $reassemble = "yes";

  my $cmd = "makeClusterFile --idSQL \"$sql\" --clusterFile $clusterFile.$suffix";

  $mgr->runCmd($cmd);

  &runAssemblePlugin($clusterFile, $suffix, $name, $old, $reassemble);

  $mgr->endStep($signal);
    my $msg = 
"EXITING.... PLEASE DO THE FOLLOWING:
 1. resume when reassembly completes (validly) by re-runnning 'dotsbuild $propertiesFile'
";
    print STDERR $msg;
    print $msg;
    $mgr->goodbye($msg);
}

sub deleteAssembliesWithNoAssemblySequences {

  my ($name) = @_;
  
  my $taxonId = $propertySet->getProp('taxonId');

  my $args = "--taxon_id $taxonId";
  
  $mgr->runPlugin("${name}deleteAssembliesWithNoAssSeq", 
		  "DoTS::DotsBuild::Plugin::DeleteAssembliesWithNoAssemblySequences",
		  $args, "Deleting assemblies with no assemblysequences");
  
}

sub matrix {
    my ($name) = @_;

    &copyDotsToLiniac($name);

    &startDotsMatrixOnLiniac($name);  

    &copyDotsMatrixFromLiniac($name);
}

sub copyDotsToLiniac {
    my ($name) = @_;

    my $serverPath = $propertySet->getProp('serverPath');
    my $liniacServer = $propertySet->getProp('liniacServer');

    my $seqfilesDir = "$pipelineDir/seqfiles";
    my $f = "${name}Dots.fsa";

    my $signal = "${name}Dots2liniac";
    return if $mgr->startStep("Copying $seqfilesDir/$f to $serverPath/$buildName/seqfiles on $liniacServer", $signal);

    $mgr->copyToLiniac($seqfilesDir, $f, $liniacServer, "$serverPath/$buildName/seqfiles");

    $mgr->endStep($signal);
}

sub startDotsMatrixOnLiniac {
    my ($name) = @_;

    my $serverPath = $propertySet->getProp('serverPath');

    my $signal = "${name}DotsMatrix";
    return if $mgr->startStep("Starting ${name}Dots matrix", $signal);
    
    $mgr->endStep($signal);

    my $cmd = "run" . ucfirst($signal);

    my $liniacCmdMsg = "submitPipelineJob $cmd $serverPath/$buildName NUMBER_OF_NODES";
    my $liniacLogMsg = "monitor $serverPath/$buildName/logs/*.log and xxxxx.xxxx.stdout";

    $mgr->exitToLiniac($liniacCmdMsg, $liniacLogMsg, 0);
}

sub copyDotsMatrixFromLiniac {
    my($name) = @_;

    my $serverPath = $propertySet->getProp('serverPath');
    my $liniacServer = $propertySet->getProp('liniacServer');

    my $signal = "${name}DotsMatrixFromLiniac";

    return if $mgr->startStep("Copying ${name}Dots matrix from $liniacServer", 
			 $signal);

    $mgr->copyFromLiniac($liniacServer, 
			 "$serverPath/$buildName/matrix/${name}Dots-${name}Dots/master/mainresult", 
			 "blastMatrix.out.gz", 
			 "$pipelineDir/matrix/${name}Dots-${name}Dots");

    $mgr->endStep($signal);
}

sub sortClusters {
    my $signal = "sortClusters";

    return if $mgr->startStep("Sort clusters into descending order", $signal);
    
    my $in = "$pipelineDir/cluster/gene/cluster.out";
    my $out = "$pipelineDir/cluster/gene/cluster.out.descending";

    $mgr->runCmd("sort --numeric-sort --field-separator ' ' --key 2.2 --reverse $in > $out");

    $mgr->endStep($signal);
}

sub loadRNAClusters {
  my $file = "$pipelineDir/cluster/gene/cluster.out.descending";
  my $args = "--sort_desc --clusterfile $file";

  $mgr->runPlugin("loadRNAClusters", "DoTS::DotsBuild::Plugin::MakeRNAClustersForAssemblies", $args,
	       "Loading RNA Clusters");
}

sub deleteGenesWithNoRNA {

  my $user = $propertySet->getProp('userId');

  my $args = "--user_id $user";

  $mgr->runPlugin("deleteGenesWithNoRNA", "DoTS::DotsBuild::Plugin::DeleteGenesWithNoRNA",$args,"Deleting genes with no rna");

}

sub insertNRDB {

  my $externalDbDir = $propertySet->getProp('externalDbDir');
  
  my $date = $propertySet->getProp('buildDate');

  my $dbi_str = $propertySet->getProp('dbi_str');

  my $sourceDB = $propertySet->getProp('sourceDB');

  my $nrdb_maketemp = $propertySet->getProp('nrdb_maketemp');

  my $nrdb_plugin = $propertySet->getProp('nrdb_plugin');

  my $nrdb_delete = $propertySet->getProp('nrdb_delete');

  my $maketemp = $nrdb_maketemp eq "yes" ? "--maketemp" : "";
  
  my $plugin = $nrdb_plugin eq "yes" ? "--plugin" : "";

  my $delete = $nrdb_delete eq "yes" ? "--delete" : "";

  my $gitax = "$externalDbDir/taxonomy/$date/gi_taxid_prot.dmp";
  
  my $nrdb = "$externalDbDir/nrdb/$date/nr";
  
  my $temp_login = $propertySet->getProp('tempLogin');  
  
  my $temp_password = $propertySet->getProp('tempPassword'); 
  
  my $restart = $propertySet->getProp('nrdbRestart') > 1 ? "--restart " . $propertySet->getProp('nrdbRestart') : "";
  
  my $nrdbReleaseId = $propertySet->getProp('nrdb_db_rls_id');
  
  my $args = "--temp_login \"$temp_login\" --sourceDB $sourceDB --temp_password \"$temp_password\" --dbi_str \"$dbi_str\" $restart --gitax $gitax --nrdb $nrdb --extDbRelId $nrdbReleaseId $maketemp $plugin $delete";

  $mgr->runPlugin("loadNRDB", "GUS::Common::Plugin::LoadNRDB", $args, "Loading NRDB", 'downloadNRDB');
}	



sub extractNRDB {

    my $nrdbReleaseId = $propertySet->getProp('nrdb_db_rls_id');

    my $sql = "select aa_sequence_id,'source_id='||source_id,'secondary_identifier='||secondary_identifier,description,'length='||length,sequence from dots.ExternalAASequence where external_database_release_id = $nrdbReleaseId";
    
    &extractProteinSeqs("nrdb", $sql);
}

sub extractProteinSeqs {
    my ($name, $sql) = @_;

    my $signal = "${name}Extract";

    return if $mgr->startStep("Extracting $name protein sequences from GUS", $signal);

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $seqFile = "$pipelineDir/seqfiles/$name.fsa";
    my $logFile = "$pipelineDir/logs/${name}Extract.log";

    my $cmd = "dumpSequencesFromTable.pl --gusConfigFile $gusConfigFile  --outputFile $seqFile --idSQL \"$sql\" --verbose 2>> $logFile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub downloadCDD {

    # produces seqfiles/cdd.tar

    my $signal = "downloadCDD";

    return if $mgr->startStep("Downloading CDD", $signal, 'downloadCDD');

    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('cddDate');

    my $downloadSubDir = "$externalDbDir/cdd/$date";
    
    $mgr->runCmd("mkdir -p $downloadSubDir");

    my $logfile = "$pipelineDir/logs/$signal.log";

    $mgr->runCmd("/bin/rm -fr $downloadSubDir/*");

    $mgr->runCmd("mkdir -p $downloadSubDir");

    my $cmd = "wget -t5 -b -m -np -nd -nH -o $logfile --cut-dirs=3 -A \"cdd.tar.gz\"  -P $downloadSubDir ftp://ftp.ncbi.nih.gov/pub/mmdb/cdd/";
	
    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub unpackCDD {

    my $signal = "unpackCDD";
    return if $mgr->startStep("Unpacking CDD files", $signal, 'downloadCDD');
    
    my $logFile = "$pipelineDir/logs/$signal.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('cddDate');

    my $downloadSubDir = "$externalDbDir/cdd/$date";

    $mgr->runCmd("gunzip $downloadSubDir/cdd.tar.gz") unless (-e "$downloadSubDir/cdd.tar");

    $mgr->runCmd("tar --extract --file $downloadSubDir/cdd.tar -C $downloadSubDir");

    if (-e "$downloadSubDir/LOAD") {
      $mgr->runCmd("rm -f $downloadSubDir/LOAD");
    }

    $mgr->runCmd("catFiles --fileGlob  '$downloadSubDir/LOAD*.csq' --outFile $downloadSubDir/LOAD");
 
    if (-e "$downloadSubDir/PFAM") {
      $mgr->runCmd("rm -f $downloadSubDir/PFAM");
    }

    $mgr->runCmd("catFiles --fileGlob '$downloadSubDir/pfam*.csq' --outFile $downloadSubDir/PFAM");

    if (-e "$downloadSubDir/SMART") {
      $mgr->runCmd("rm -f $downloadSubDir/SMART");
    }
    
    $mgr->runCmd("catFiles --fileGlob '$downloadSubDir/smart*.csq' --outFile $downloadSubDir/SMART");

    if (-e "$downloadSubDir/COG") {
      $mgr->runCmd("rm -f $downloadSubDir/COG");
    }
    
    $mgr->runCmd("catFiles --fileGlob '$downloadSubDir/COG*.csq' --outFile $downloadSubDir/COG");

    if (-e "$downloadSubDir/CD") {
      $mgr->runCmd("rm -f $downloadSubDir/CD");
    }
    
    $mgr->runCmd("catFiles --fileGlob '$downloadSubDir/cd*.csq' --outFile $downloadSubDir/CD");
    
    $mgr->runCmd("rm -r $downloadSubDir/cdd.tar");
	
    $mgr->endStep($signal);
}

sub insertCDD {

  my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('cddDate');

    my $downloadSubDir = "$externalDbDir/cdd/$date";

    my $loadDB = $propertySet->getProp('load_db_rls_id');
    
    # >gnl|CDD|3794 LOAD_ACT, ACT, small ligand binding domain
    my $regex_src_id = "^\\>\\w+\\|\\w+\\|\\w+\\s(LOAD[\\_\\w]+)\\,\\s";
    my $regex_name = "^\\S+\\sLOAD[\\_\\w]+\\,\\s([\\w\\_\\s]+)\\,\\s";
    my $regex_desc = "^\\S+\\sLOAD[\\_\\w]+\\,\\s(.*)";
    
    my $loadArgs = "--verbose --table_name 'DoTS::MotifAASequence' --sequencefile '$downloadSubDir/LOAD' --external_database_release_id $loadDB --regex_source_id \"$regex_src_id\" --regex_name \"$regex_name\"  --regex_desc \"$regex_desc\"";

    $mgr->runPlugin("insertLoad", 
		    "GUS::Common::Plugin::InsertNewExternalSequences", 
		    $loadArgs,
		   "Inserting Load", 'downloadCDD');

    my $pfamDB = $propertySet->getProp('pfam_db_rls_id');

    #>gnl|Pfam|pfam00291 PALP, Pyridoxal-phosphate dependent enzyme
    $regex_src_id = "^\\>\\w+\\|\\w+\\|\\w+\\s(pfam\\w+)";
    $regex_name = "^\\S+\\spfam\\w+\\,\\s([\\w\\_\\s]+)\\,\\s";
    $regex_desc = "^\\S+\\spfam\\w+\\,\\s(.*)";
    
    my $pfamArgs = "--verbose --table_name 'DoTS::MotifAASequence' --sequencefile '$downloadSubDir/PFAM' --external_database_release_id $pfamDB --regex_source_id \"$regex_src_id\" --regex_name \"$regex_name\"  --regex_desc \"$regex_desc\"";
    
    $mgr->runPlugin("insertPfam", "GUS::Common::Plugin::InsertNewExternalSequences", $pfamArgs,
		   "Inserting Pfam", 'downloadCDD');
    
    my $smartDB = $propertySet->getProp('smart_db_rls_id');
    
    #>gnl|Smart|smart00238 BIR, Baculoviral inhibition of apoptosis protein repeat; Domain found in inhibitor of apoptosis proteins (IAPs) and other proteins. Acts as a direct inhibitor of caspase enzymes
    $regex_src_id = "^\\>\\w+\\|\\w+\\|\\w+\\s(smart\\w+)";
    $regex_name = "^\\S+\\ssmart\\w+\\,\\s([\\w\\_\\s]+)\\,\\s";
    $regex_desc = "^\\S+\\ssmart\\w+\\,\\s(.*)";
    
    my $smartArgs = "--verbose --table_name 'DoTS::MotifAASequence' --sequencefile '$downloadSubDir/SMART' --external_database_release_id $smartDB  --regex_source_id \"$regex_src_id\" --regex_name \"$regex_name\"  --regex_desc \"$regex_desc\"";
    
    $mgr->runPlugin("insertSmart", 
		    "GUS::Common::Plugin::InsertNewExternalSequences", 
		    $smartArgs,
		    "Inserting Smart", 'downloadCDD');

  my $cogDB = $propertySet->getProp('cog_db_rls_id');

  $regex_src_id = "^\\>\\w+\\|\\w+\\|\\w+\\s(COG\\w+)";
  $regex_name = "^\\S+\\sCOG\\w+\\,\\s([\\w\\_\\s]+)\\,\\s";
  $regex_desc = "^\\S+\\sCOG\\w+\\,\\s(.*)";
  
  my $cogArgs = "--verbose --table_name 'DoTS::MotifAASequence' --sequencefile '$downloadSubDir/COG' --external_database_release_id $cogDB  --regex_source_id \"$regex_src_id\" --regex_name \"$regex_name\"  --regex_desc \"$regex_desc\"";
  
  $mgr->runPlugin("insertCOG", 
		  "GUS::Common::Plugin::InsertNewExternalSequences", 
		  $cogArgs,
		  "Inserting COG", 'downloadCDD');

  my $cdDB = $propertySet->getProp('cd_db_rls_id');
  
  $regex_src_id = "^\\>\\w+\\|\\w+\\|\\w+\\s(cd\\w+)";
  $regex_name = "^\\S+\\scd\\w+\\,\\s([\\w\\_\\s]+)\\,\\s";
  $regex_desc = "^\\S+\\scd\\w+\\,\\s(.*)";
  
  my $cdArgs = "--verbose --table_name 'DoTS::MotifAASequence' --sequencefile '$downloadSubDir/CD' --external_database_release_id $cdDB  --regex_source_id \"$regex_src_id\" --regex_name \"$regex_name\"  --regex_desc \"$regex_desc\"";
  
  $mgr->runPlugin("insertCD", 
		  "GUS::Common::Plugin::InsertNewExternalSequences", 
		  $cdArgs,
		  "Inserting CD", 'downloadCDD');
  
}

sub downloadProdom {

    my $signal = "downloadProdom";

    return if $mgr->startStep("Downloading Prodom", $signal, 'downloadProdom');

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');

    my $downloadSubDir = "$externalDbDir/prodom/$date";
    
    $mgr->runCmd("mkdir -p $downloadSubDir");

    my $logfile = "$pipelineDir/logs/$signal.log";

    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    $mgr->runCmd("/bin/rm -f $downloadSubDir/*");

    $mgr->runCmd("mkdir -p $downloadSubDir");

    my $cmd = "wget -t5 -b -m -np -nd -nH -o $logfile  --cut-dirs=3 -A \"prodom.cons.gz\"  -P $downloadSubDir ftp://ftp.toulouse.inra.fr/pub/prodom/current_release/";
    
    $mgr->runCmd($cmd);
    $mgr->runCmd("gunzip $downloadSubDir/prodom.cons.gz");
    
    $mgr->endStep($signal);
}

sub insertProdom {

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');
    
    my $downloadSubDir = "$externalDbDir/prodom/$date";

    my $prodomFile = "$downloadSubDir/prodom.cons";

    my $logFile = "$pipelineDir/logs/insertProdom.log";

    my $prodomDB = $propertySet->getProp('prodom_db_rls_id');

    #>PD000001 p2001.3 (5600) KIT(16) KPC1(13) CDC2(13) // KINASE TRANSFERASE ATP-BINDING SERINE/THREONINE-PROTEIN RECEPTOR TYROSINE-PROTEIN 2.7.1.-PHOSPHORYLATION PRECURSOR
    #>CONSENSUS#PD000001 | 380 | pd_PD000001; | (5600)  KINASE TRANSFERASE ATP-BINDING SERINE/THREONINE-PROTEIN RECEPTOR TYROSINE-PROTEIN 2.7.1.- PHOSPHORYLATION DOMAIN SERINE/THREONINE  as of 2003.1
    #my $regex_src_id = "^\\>(\\w+)"; 
    my $regex_src_id = "^\\>CONSENSUS#(\\w+)";
    my $regex_contained_seqs = "\\((\\d+)";
    #my $regex_name = "(\\(.+)\\s\\/\\/";
    #my $regex_desc = "\\/\\/\\s(.+)";
    my $regex_desc = "\\)\\s+(.+)";

    my $args = "--verbose --table_name DoTS::MotifAASequence --sequencefile $prodomFile --external_database_release_id $prodomDB --regex_source_id \"$regex_src_id\"  --regex_contained_seqs \"$regex_contained_seqs\" --regex_desc \"$regex_desc\"";

    $mgr->runPlugin("insertProdom", 
		    "GUS::Common::Plugin::InsertNewExternalSequences", $args,
		    "Inserting Prodom", 'downloadProdom');
}

sub extractProdom {

    my $prodomDB = $propertySet->getProp('prodom_db_rls_id');

    my $sql = "select aa_sequence_id,'source_id='||source_id,'secondary_identifier='||secondary_identifier,description,'length='||length,sequence from dots.MotifAASequence where external_database_release_id = $prodomDB";
    
    &extractProteinSeqs("prodom", $sql);
}

sub copyProteinDBsToLiniac {

    my ($name) = @_;

    my $serverPath = $propertySet->getProp('serverPath');
    my $liniacServer = $propertySet->getProp('liniacServer');

    my $signal = "proteinDBs2Liniac";
    return if $mgr->startStep("Copying NRDB, CDD and Prodom to $serverPath/$buildName/seqfiles on $liniacServer", $signal);

    my $release = "release" . $propertySet->getProp('dotsRelease');
    my $protDir = $propertySet->getProp('proteinDir');
    my $seqfilesDir = "$dotsBuildDir/$release/$protDir/seqfiles";
    my $f = "nrdb.fsa";
    $mgr->copyToLiniac($seqfilesDir, $f, $liniacServer, 
		       "$serverPath/$buildName/seqfiles");

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('cddDate');

    my $downloadSubDir = "$externalDbDir/cdd";

    my $tmpCddDir = "$downloadSubDir/cdd";

    die "$tmpCddDir exists but it shouldn't" if -e $tmpCddDir;

    $mgr->runCmd("ln -s $downloadSubDir/$date $tmpCddDir"); 

    $mgr->copyToLiniac($downloadSubDir, "cdd", $liniacServer, 
		       "$serverPath/$buildName/seqfiles");

    $mgr->runCmd("rm -f $tmpCddDir"); 

    $f = "prodom.fsa";
    $mgr->copyToLiniac($seqfilesDir, $f, $liniacServer,
		       "$serverPath/$buildName/seqfiles");

    $mgr->endStep($signal);
}

sub startSimilaritiesOnLiniac {
    my ($name) = @_;

    my $serverPath = $propertySet->getProp('serverPath');

    my $signal = "findSimilarities";
    return if $mgr->startStep("Starting NRDB, CDD and Prodom similarites on liniac", $signal);
    
    $mgr->endStep($signal);

    my $liniacCmdMsg = "submitPipelineJob runSimilarities $serverPath/$buildName NUMBER_OF_NODES";
    my $liniacLogMsg = "monitor $serverPath/$buildName/logs/*.log and xxxxx.xxxx.stdout";

    $mgr->exitToLiniac($liniacCmdMsg, $liniacLogMsg, 1);
}

sub copySimilaritiesFromLiniac {

    my $serverPath = $propertySet->getProp('serverPath');
    my $liniacServer = $propertySet->getProp('liniacServer');

    my $signal = "copySimilaritiesFromLiniac";
    return if $mgr->startStep("Copying protein similarities from $liniacServer", 
			 $signal);
    my @names = ("finalDots-nrdb","finalDots-prodom", "finalDots-cdd");
    foreach my $name (@names) {
	$mgr->copyFromLiniac($liniacServer, 
			     "$serverPath/$buildName/similarity/$name/master/mainresult", 
			     "blastSimilarity.out.gz", 
			     "$pipelineDir/similarity/$name");
    }
    $mgr->endStep($signal);
}

sub deleteOldSimilarities {

    my $taxonId = $propertySet->getProp('taxonId');    
    my $nrdbRel = $propertySet->getProp('nrdb_db_rls_id');
    my $prodomRel = $propertySet->getProp('prodom_db_rls_id');
    my $smartRel = $propertySet->getProp('smart_db_rls_id');
    my $pfamRel = $propertySet->getProp('pfam_db_rls_id');
    my $loadRel = $propertySet->getProp('load_db_rls_id');
    my $cogRel = $propertySet->getProp('cog_db_rls_id');
    my $cdRel = $propertySet->getProp('cd_db_rls_id');
    
    my $sql = "select /*+ RULE */ similarity_id from dots.similarity s, dots.assembly a, dots.aasequenceimp aas where s.query_table_id = 56 and s.query_id = a.na_sequence_id and a.taxon_id = $taxonId  and s.subject_table_id in (83,84,277) and s.subject_id = aas.aa_sequence_id and aas.external_database_release_id in ($nrdbRel,$prodomRel,$smartRel,$pfamRel,$loadRel,$cogRel,$cdRel)";

    my $args = "--idSQL \"$sql\" ";

    $mgr->runPlugin("deleteProteinSims", 
		    "GUS::Common::Plugin::DeleteSimilarities", $args,
		    "Deleting old protein similarities");
}

sub insertProteinSimilarities {
    my ($name, $subjectTable) = @_;

    my $file = "$pipelineDir/similarity/$name/blastSimilarity.out.gz";
    $file .= ".correctPK" if ($name eq "finalDots-cdd");
    my $prop = "iPSRestart_$name";
    my $restart = $propertySet->getProp($prop);

    my $args = "--file $file --restartAlgInvs $restart --queryTable DoTS::Assembly --subjectTable $subjectTable --subjectsLimit 50 --hspsLimit 10";

    $mgr->runPlugin("loadSims_$name", 
		    "GUS::Common::Plugin::LoadBlastSimFast", $args,
		    "Loading $name similarities");
}

sub substituteCDDPKs {
    
    my $smartDB = $propertySet->getProp('smart_db_rls_id');

    my $pfamDB = $propertySet->getProp('pfam_db_rls_id');

    my $loadDB = $propertySet->getProp('load_db_rls_id');

    my $cogDB = $propertySet->getProp('cog_db_rls_id');

    my $cdDB = $propertySet->getProp('cd_db_rls_id');

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $signal = "substituteCDDPKs";

    return if $mgr->startStep("Substitituting primary keys into CDD similarities file",
			 $signal);
    
    my $file = "$pipelineDir/similarity/finalDots-cdd/blastSimilarity.out.gz";
    $mgr->runCmd("gunzip $file");
    my $infile = "$pipelineDir/similarity/finalDots-cdd/blastSimilarity.out";
    my $outfile = "$pipelineDir/similarity/finalDots-cdd/blastSimilarity.out.gz.correctPK";
    my $logfile = "$pipelineDir/logs/$signal.log";

    my $sql = "select source_id,aa_sequence_id from dots.motifaasequence where external_database_release_id in ($smartDB,$pfamDB,$loadDB,$cogDB,$cdDB)";

    $mgr->runCmd("cat $infile | substitutePrimKeysInSimilarity --subjectSQL \"$sql\" --verbose --gusConfigFile $gusConfigFile > $outfile 2>> $logfile");

    $mgr->endStep($signal);
}

sub assignSequenceDescription {

    my $taxonId = $propertySet->getProp('taxonId');

    my $dotsRelease = $propertySet->getProp('dotsRelease');
    my $speciesNickname = $propertySet->getProp('speciesNickname');
    my $nrdbReleaseId = $propertySet->getProp('nrdb_db_rls_id');

    my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}"; 

    my $assignDescriptionRestart = $propertySet->getProp('assignDescriptionRestart');
                                                          

    my $restart = $assignDescriptionRestart > 1 ? "--restart \"select na_sequence_id from dots.assembly where row_alg_invocation_id in ($assignDescriptionRestart)\"" : "";

    my $dotsMGIfile = "$pipelineDir/misc/${prefix}_bestNRDBHits.dat";
    my $sql = "select na_sequence_id,na_sequence_id from dots.Assembly where taxon_id = $taxonId";

    my $args = "--update_rna_descriptions --copy_manual_descriptions --taxon_id $taxonId --table DoTS::Assembly --query_table DoTS::Assembly $restart --doNotVersion --nrdb_ext_db_rls_id $nrdbReleaseId --dots_mgi_file $dotsMGIfile  --idSQL \"$sql\"";

    $mgr->runPlugin("assignSeqDescrip", 
		    "DoTS::DotsBuild::Plugin::AssignSequenceDescription",
		    $args,
		    "Assigning sequence descriptions from MGI"); 
}

sub deleteIndexWords {
    
    my $signal = "deleteIndexWords";

    return if $mgr->startStep("Deleting index_word_link_ids for assemblies from GUS", $signal);

    my $taxonId = $propertySet->getProp('taxonId');

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $logFile = "$pipelineDir/logs/$signal.log";

    my $sql = "select index_word_link_id from dots.indexwordlink l,dots.assembly a where a.taxon_id = $taxonId and a.na_sequence_id = l.target_id and l.target_table_id = 56";

    my $cmd = "deleteEntries.pl --table DoTS::IndexWordLink --idSQL \"$sql\" --verbose 2>> $logFile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub makeIndexWords {

    my $taxonId = $propertySet->getProp('taxonId');

    my $sql = "select na_sequence_id,description from dots.Assembly where taxon_id = $taxonId";

    my $args = "--attribute description --restart --table DoTS::Assembly --idSQL \"$sql\"";

    $mgr->runPlugin("makeIndexWords", 
		    "GUS::Common::Plugin::MakeIndexWordLink", $args, 
		    "Index assembly description words & add entries to IndexWordLink");
}
 

sub deleteNRDBIndexWords {

  my $signal = "deleteNRDBIndexWords";

  return if $mgr->startStep("Deleting nrdb index word links from GUS",
			    $signal, 'downloadNRDB');

  my $buildDate = $propertySet->getProp('buildDate');
  my $nrdbReleaseId = $propertySet->getProp('nrdb_db_rls_id');

  my $logFile = "$pipelineDir/logs/$signal.log";

  my $sql = "select index_word_link_id from dots.indexwordlink l,dots.externalaasequence e where e.aa_sequence_id = l.target_id and l.target_table_id = 83 and e.external_database_release_id = $nrdbReleaseId  and e.modification_date > '$buildDate'";

  my $cmd = "deleteEntries.pl --table DoTS::IndexWordLink --idSQL \"$sql\" --verbose 2>> $logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);
}

sub deleteMotifIndexWords {

  my $signal = "deleteMotifIndexWords";

  return if $mgr->startStep("Deleting motif index word links from GUS",
			    $signal, 'downloadCDD');

  my $buildDate = $propertySet->getProp('buildDate');

  my $logFile = "$pipelineDir/logs/$signal.log";

  my $sql = "select index_word_link_id from dots.indexwordlink l,dots.motifaasequence m where m.aa_sequence_id = l.target_id and l.target_table_id = 277 and m.modification_date > '$buildDate'";

  my $cmd = "deleteEntries.pl --table DoTS::IndexWordLink --idSQL \"$sql\" --verbose 2>> $logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);
}

sub makeNRDBIndexWordLink {

  my $nrdbReleaseId = $propertySet->getProp('nrdb_db_rls_id');

  my $sql = "select aa_sequence_id, description from dots.ExternalAASequence where external_database_release_id=$nrdbReleaseId and aa_sequence_id not in (select target_id from  dots.IndexWordLink where target_table_id=83)";

  my $args = "--attribute description --table DoTS::ExternalAASequence --idSQL \"$sql\"";

  $mgr->runPlugin("makeNRDBIndexWordLink", 
		  "GUS::Common::Plugin::MakeIndexWordLink", $args, 
		  "Making nrdb index word links", 'downloadNRDB');
}

sub makeMotifIndexWordLink {

  my $prodomReleaseId = $propertySet->getProp('prodom_db_rls_id');
  my $smartReleaseId = $propertySet->getProp('smart_db_rls_id');
  my $loadReleaseId = $propertySet->getProp('load_db_rls_id');
  my $pfamReleaseId = $propertySet->getProp('pfam_db_rls_id');
  my $cogReleaseId = $propertySet->getProp('cog_db_rls_id');
  my $cdReleaseId = $propertySet->getProp('cd_db_rls_id');

  my $sql = "select aa_sequence_id, description from dots.MotifAASequence where external_database_release_id in ($prodomReleaseId,$smartReleaseId,$loadReleaseId,$pfamReleaseId,$cogReleaseId,$cdReleaseId) and aa_sequence_id not in (select target_id from  dots.IndexWordLink where target_table_id=277)";

  my $args = "--attribute description --table DoTS::MotifAASequence --idSQL \"$sql\"";

  $mgr->runPlugin("makeMotifIndexWordLink", 
		  "GUS::Common::Plugin::MakeIndexWordLink", $args, 
		  "Making motif index word links", 'downloadCDD');
}
 
sub indexSimilarityWords { 

    my $taxonId = $propertySet->getProp('taxonId');

    my $sql = "select a.na_sequence_id from dots.assembly a where a.taxon_id = $taxonId";
    
    my $args = "--similarity_table DoTS::MotifAASequence --target_table DoTS::Assembly --idSQL \"$sql\"";

    $mgr->runPlugin("indexSimilarityWords", 
		    "GUS::Common::Plugin::MakeIndexWordSimLink", $args, 
		    "Indexing words in similarity descriptions");
}

sub indexNRDBWords { 

    my $taxonId = $propertySet->getProp('taxonId');

    my $sql = "select a.na_sequence_id from dots.assembly a where a.taxon_id = $taxonId";
    
    my $args = "--similarity_table DoTS::ExternalAASequence --target_table DoTS::Assembly --idSQL \"$sql\"";

    $mgr->runPlugin("indexNRDBWords", 
		    "GUS::Common::Plugin::MakeIndexWordSimLink", $args, 
		    "Indexing words in NRDB descriptions");
}


sub getIdsPerAssembly {

    my $signal = "getIdsPerAssembly";

    return if $mgr->startStep("Getting ids per assembly", $signal);

    my $taxonId = $propertySet->getProp('taxonId');

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $dotsRelease = $propertySet->getProp('dotsRelease');
    my $speciesNickname = $propertySet->getProp('speciesNickname');

    my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

    my $output  = "$pipelineDir/misc/${prefix}_accessionsPerAssembly.dat";

    my $cmd = "getIdsPerAssembly --taxon_id $taxonId --gusConfigFile $gusConfigFile  > $output";

    $mgr->runCmd($cmd);

    my $cmd = "gzip $output";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);

}

sub getImcloneOnlyAssemblies {

    my $signal = "getImcloneOnlyAssemblies";

    return if $mgr->startStep("Getting Imclone assembly ids", $signal);

    my $taxonId = $propertySet->getProp('taxonId');

    my $imcloneReleaseId = $propertySet->getProp('imclone_db_rls_id');

    my $sql = "select distinct (s.assembly_na_sequence_id) from dots.assemblysequence s, dots.externalnasequence e where s.na_sequence_id = e.na_sequence_id and e.taxon_id = 14 and e.external_database_release_id = $imcloneReleaseId minus (select s.assembly_na_sequence_id from dots.assemblysequence s, dots.externalnasequence e where s.na_sequence_id = e.na_sequence_id and e.taxon_id = $taxonId and e.external_database_release_id != $imcloneReleaseId)";

    my $output = "$pipelineDir/misc/imcloneOnlyAssemblies.dat";

    my $logfile = "$pipelineDir/logs/${signal}.log";

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $cmd = "getPrimaryIds --outputfile $output --gusConfigFile $gusConfigFile  --idSQL \"$sql\" --verbose 2>> $logfile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);

}

sub getAssembliesPerGene {

  my $signal = "getAssembliesPerGene";

  return if $mgr->startStep("Getting assemblies per gene", $signal);

  my $taxonId = $propertySet->getProp('taxonId');

  my $gusConfigFile = $propertySet->getProp('gusConfigFile');

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $speciesNickname = $propertySet->getProp('speciesNickname');

  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  my $output  = "$pipelineDir/misc/${prefix}_DTperDG.dat";

  my $cmd = "getAssPerGene --taxon_id $taxonId --gusConfigFile $gusConfigFile  > $output";

  $mgr->runCmd($cmd);

  my $cmd = "gzip $output";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);

}

sub makeEpconFastaFiles {

  my $signal = "makeEpconFastaFiles";

  return if $mgr->startStep("Making EpConDB fasta files", $signal);

  my $speciesNickname = $propertySet->getProp('speciesNickname');

  my $logFile ="$pipelineDir/logs/${signal}.log";

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $outputFile  = "$pipelineDir/misc/EPConDB_rel${dotsRelease}_${speciesNickname}DoTS";

  my $taxonId = $propertySet->getProp('taxonId');

  my $species = $propertySet->getProp('speciesFullname');

  my $epconDB_anatomy_ids = $propertySet->getProp('epconDB_anatomy_ids');

  my $epconDB_array = $propertySet->getProp('epconDB_array');
  
  my $epconDB_chip = $propertySet->getProp('epconDB_chip');

  my $epconDB_makefile = $propertySet->getProp('epconDB_makefile');

  my $gusConfigFile = $propertySet->getProp('gusConfigFile');

  my $sql = "select 'DT.' ||a.na_sequence_id, '[ $species ]', a.description ,'('||number_of_contained_sequences || ' sequences)', 'length=' || a.length ,sequence from dots.assembly a, dots.assemblyanatomypercent p where p.anatomy_id in ($epconDB_anatomy_ids) and p.percent>0 and a.na_sequence_id=p.na_sequence_id and p.taxon_id=a.taxon_id and a.taxon_id=$taxonId";

  my $cmd = "dumpSequencesFromTable.pl --verbose --gusConfigFile $gusConfigFile --outputFile $outputFile --idSQL \"$sql\" 2>>  $logFile";

  $mgr->runCmd($cmd);

  my $outputFile  = "$pipelineDir/misc/${epconDB_chip}_rel${dotsRelease}${speciesNickname}DoTS";

  my $sql = "select 'DT.' ||a.na_sequence_id, '[ $species ]', a.description ,'(' ||number_of_contained_sequences || ' sequences)' , 'length=' ||a.length, sequence from rad3.elementassembly_mv ea , rad3.spot s, dots.assembly a where s.array_id = $epconDB_array and s.element_id = ea.element_id and ea.assembly_na_sequence_id = a.na_sequence_id";

  my $cmd = "dumpSequencesFromTable.pl --verbose --gusConfigFile $gusConfigFile --outputFile $outputFile --idSQL \"$sql\" 2>>  $logFile";

  $mgr->runCmd($cmd) if $epconDB_makefile eq 'yes';

  $mgr->endStep($signal);

}


sub getmRNAPerAssembly {

  my $signal = "getmRNAPerAssembly";

  return if $mgr->startStep("Getting mRNA per Assembly", $signal);

  my $taxonId = $propertySet->getProp('taxonId');

  my $gusConfigFile = $propertySet->getProp('gusConfigFile');

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $speciesNickname = $propertySet->getProp('speciesNickname');

  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  my $output  = "$pipelineDir/misc/${prefix}_mRNAaccessionsPerAssembly.dat";

  my $cmd = "getmRNAperAssembly --taxon_id $taxonId --gusConfigFile $gusConfigFile  > $output";

  $mgr->runCmd($cmd);

  my $cmd = "gzip $output";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);

}


sub prepareDownloadSiteFiles {

  my $signal = "prepareDownloadSiteFiles";
  
  return if $mgr->startStep("Preparing files for download site", $signal);

  my @files;
  my $htaccessString;
  my $descrip;

  my $dotsRelease = $propertySet->getProp('dotsRelease');
  my $speciesNickname = $propertySet->getProp('speciesNickname');
  my $speciesFullname = $propertySet->getProp('speciesFullname');
  my $gusConfigFile = $propertySet->getProp('gusConfigFile');
  my $taxonId = $propertySet->getProp('taxonId');
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  # readme file header
  &writeReadmeFileHeader();

  # fasta file of sequences
  my $fastaFile = "${prefix}.fasta";
  my $logFile = "$pipelineDir/logs/${fastaFile}Extract.log";
  my $sql = "select 'DT.'||na_sequence_id,'[$speciesNickname]',description,'('||number_of_contained_sequences||' sequences)','length='||length,sequence from dots.Assembly where taxon_id = $taxonId";
  my $cmd = "dumpSequencesFromTable.pl --outputFile $pipelineDir/seqfiles/$fastaFile --verbose --gusConfigFile $gusConfigFile  --idSQL \"$sql\" 2>>  $logFile";
  $mgr->runCmd($cmd);
  my $cmd = "gzip $pipelineDir/seqfiles/$fastaFile";
  $mgr->runCmd($cmd) unless -e "$pipelineDir/seqfiles/${fastaFile}.gz";
  push(@files, "$pipelineDir/seqfiles/${fastaFile}.gz");
  $descrip = "The sequence for the consensus transcripts";
  $htaccessString .= "AddDescription \"$descrip\" *fasta*\n";
  addFileToReadme("${fastaFile}.gz", $descrip);

  # predicted proteins
  my $predictedProteinsFile = "${prefix}_predictedProteins.fasta";
  my $logFile = "$pipelineDir/logs/${predictedProteinsFile}Extract.log";
  my $sql = "select 'DT.'||a.na_sequence_id,'length of predicted protein sequence ='||ts.length,ts.sequence from dots.translatedaasequence ts,dots.translatedaafeature tf,dots.rnafeature rf,dots.assembly a where a.taxon_id = $taxonId and a.na_sequence_id = rf.na_sequence_id and rf.na_feature_id = tf.na_feature_id and tf.aa_sequence_id = ts.aa_sequence_id";
  my $cmd = "dumpSequencesFromTable.pl --outputFile $pipelineDir/seqfiles/$predictedProteinsFile --verbose --gusConfigFile $gusConfigFile  --idSQL \"$sql\" 2>>  $logFile";
  $mgr->runCmd($cmd) unless -e "$pipelineDir/seqfiles/$predictedProteinsFile" || "$pipelineDir/seqfiles/${predictedProteinsFile}.gz";
  my $cmd = "gzip $pipelineDir/seqfiles/$predictedProteinsFile";
  $mgr->runCmd($cmd) unless -e "$pipelineDir/seqfiles/${predictedProteinsFile}.gz";
  push(@files, "$pipelineDir/seqfiles/${predictedProteinsFile}.gz");
  $descrip = "The predicted protein translation of each assembled transcript";
  $htaccessString .= "AddDescription \"$descrip\" *Proteins*\n";
  addFileToReadme("${predictedProteinsFile}.gz", $descrip);

  # NRDB Hits 
  my $nrdbHitsFile = "${prefix}_bestNRDBHits.dat";
  my $cmd = "gzip $pipelineDir/misc/$nrdbHitsFile" unless -e "$pipelineDir/misc/${nrdbHitsFile}.gz";
  $mgr->runCmd($cmd);
  push(@files, "$pipelineDir/misc/${nrdbHitsFile}.gz");
  $descrip = "The best hit in NRDB for each consensus transcript";
  $htaccessString .= "AddDescription \"$descrip\" *NRDB*\n";
  addFileToReadme("${nrdbHitsFile}.gz", $descrip);

  # Accs Per Assembly
  push(@files, "$pipelineDir/misc/${prefix}_accessionsPerAssembly.dat.gz");
  $descrip = "The Genbank accessions of ESTs and mRNAs contained in each assembled transcript";
  $htaccessString .= "AddDescription \"$descrip\" *_acc*\n";
  addFileToReadme("${prefix}_accessionsPerAssembly.dat.gz", $descrip);

  # DTs per DG
  push(@files, "$pipelineDir/misc/${prefix}_DTperDG.dat.gz");
  $descrip = "Assembled transcripts belonging to each gene";
  $htaccessString .= "AddDescription \"$descrip\" *DTperDG*\n";
  addFileToReadme("${prefix}_DTperDG.dat.gz", $descrip);

  # mRNAs per DT
  push(@files, "$pipelineDir/misc/${prefix}_mRNAaccessionsPerAssembly.dat.gz");
  $descrip = "The Genbank accessions of mRNAs contained in each assembled transcript";
  $htaccessString .= "AddDescription \"$descrip\" *mRNA*\n";
  addFileToReadme("${prefix}_mRNAaccessionsPerAssembly.dat.gz", $descrip);

  # Brain Anatomy terms
  my $brainFile = "${prefix}_brainTerms.dat";
  my $logFile = "$pipelineDir/logs/brainTerms.log";
  my $cmd = "makeAnatomyCountFile --taxonId 8 --root brain --rootLevel level_4 --estCount 2 --percent 10 --outputfile $pipelineDir/misc/$brainFile 2>> $logFile";
  $mgr->runCmd($cmd);
  push(@files, "$pipelineDir/misc/$brainFile");
  $descrip = "Brain anatomy terms for which there are DoTS Transcripts.  (Tab delimited: term, term ID, count of DTs)";
  $htaccessString .= "AddDescription \"$descrip\" *brainTerms*\n";
  addFileToReadme($brainFile, $descrip);

  # move files to download directory
  foreach my $file (@files) {
    my $outputfile = "$pipelineDir/downloadSite/" . &basename($file);
    my $cmd = "cp $file $outputfile";
    $mgr->runCmd($cmd);
  }

  &updateHtaccessFile($htaccessString);
 
  $mgr->runCmd("chmod g+w $pipelineDir/downloadSite");

  $mgr->endStep($signal);
}

sub writeReadmeFileHeader {
  my $dotsRelease = $propertySet->getProp('dotsRelease');
  my $speciesNickname = $propertySet->getProp('speciesNickname');
  my $speciesFullname = $propertySet->getProp('speciesFullname');
 
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  my $genbankRel = $propertySet->getProp('genbankRel');
  my $nrdbDate = $propertySet->getProp('nrdbDate');
  my $cddFileDates = $propertySet->getProp('cddFileDates');
  my $dbestDate = $propertySet->getProp('dbestDate');
  my $prodomVersion = $propertySet->getProp('prodomVersion');

  my $readme = "$pipelineDir/downloadSite/${speciesNickname}_README.txt";
  open(F, ">$readme") || $mgr->error("Can't open $readme for writing");

  my $date = `date`;
  chomp $date;
  
  print F "
Release ${dotsRelease} of the Database of Transcribed Sequences (DoTS) for $speciesFullname 
was completed on $date.

The data sources include:
    * GenBank (Release $genbankRel)
    * NRDB ($nrdbDate)
    * dbEST ($dbestDate)
    * Pfam  ($cddFileDates)
    * ProDom ($prodomVersion)
    * CDD ($cddFileDates)
    * Gene Ontology (GO) consortium ontologies and assignments
    * German Gene Trap Consortium (GGTC)
    * Gene traps from the BayGenomics consortium

The files available are:

";
  close(F);
}

sub addFileToReadme {
  my ($filename, $descrip) = @_;

  my $speciesNickname = $propertySet->getProp('speciesNickname');
  my $readme = "$pipelineDir/downloadSite/${speciesNickname}_README.txt";
  open(F, ">>$readme") || $mgr->error("Can't open $readme for writing");

  print F "
$filename
    $descrip
";
}


sub createManuallyReviewedDoTSFile { 
  
  my $signal = "createManuallyReviewedDoTSFile";

  return if $mgr->startStep("Preparing manually reviewed DoTs file", $signal);

  my $dotsRelease = $propertySet->getProp('dotsRelease');
  my $speciesNickname = $propertySet->getProp('speciesNickname');
  my $tempLogin = $propertySet->getProp('tempLogin');  
  my $tempPassword = $propertySet->getProp('tempPassword'); 
  my $taxonId = $propertySet->getProp('taxonId');
  my $allgenesLogin  = $propertySet->getProp('allgenesLogin');
  
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";
  
  my $manRevwDoTSReportFile = "$pipelineDir/downloadSite/${prefix}_manuallyReviewedTranscriptsReport.txt";
    
  # create report of manually reviewed dots
  my $cmd = "gusreport --configModule GUS::ReportMaker::SampleTranscriptReportConfig --tempTableName tempResult --requestedColumns 'Description, GeneSymbol, Length, GOid, DoTSGene, SeqsInAssem, MGI, LocusLink, ContainsMRNA, Motifs, Organism, mRNASeq, proteinSeq' --sql 'select distinct pa.na_sequence_id, 9999 from DoTS.rna r, allgenes.proteinassembly pa where r.review_status_id = 1 and r.rna_id = pa.rna_id and pa.taxon_id = $taxonId' > $manRevwDoTSReportFile";
  $mgr->runCmd($cmd);

  my $cmd = "gzip $manRevwDoTSReportFile";

  $mgr->runCmd($cmd);

  my $descrip = "A tab delimited report for all manually reviewed DoTS Transcripts";
  &updateHtaccessFile("AddDescription \"$descrip\" *manuallyReviewed*\n");
  &addFileToReadme("${prefix}_manuallyReviewedTranscriptsReport.txt.gz", $descrip);

  $mgr->endStep($signal);
}

sub createPredTranslDetailsFile {

  my $signal = "createPredTranslDetailsFile";
  return if $mgr->startStep("Preparing predicted translation details file", $signal);

  my $dotsRelease = $propertySet->getProp('dotsRelease');
  my $speciesNickname = $propertySet->getProp('speciesNickname');
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";
  my $predTranslDetailsFile = "$pipelineDir/downloadSite/${prefix}_predictedProteinDetails.txt";

  my $taxonId = $propertySet->getProp('taxonId');
  
  my $cmd = "getAssTranslATGStartStop --taxon_id $taxonId >$predTranslDetailsFile";  
  $mgr->runCmd($cmd);

  my $cmd = "gzip $predTranslDetailsFile";
  $mgr->runCmd($cmd);

  my $descrip = "A tab delimited file of the translation details for all the predicted proteins";
  &updateHtaccessFile("AddDescription \"$descrip\" *Details*\n");
  &addFileToReadme("${prefix}_predictedProteinDetails.txt.gz", $descrip);

  $mgr->endStep($signal);
}
  

sub updateHtaccessFile {
  my ($htaccessString) = @_;
  my $htaccess = "$pipelineDir/downloadSite/.htaccess";
  
  open(F, ">>$htaccess") || $mgr->error("Can't open $htaccess for writing");
  my $cmd = print F ("$htaccessString");
  close(F);
}
sub prepareEPConBlastSiteFiles {

  my $signal = "prepareEpConcdBlastSiteFiles";
  return if $mgr->startStep("Preparing EPConDB files for blast site", $signal);
  my $epconDB_makefile = $propertySet->getProp('epconDB_makefile');

  my $speciesNickname = $propertySet->getProp('speciesNickname');
  my $blastBinDir = $propertySet->getProp('wuBlastBinPath');
  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $outputFile1  = "$pipelineDir/misc/EPConDB_rel${dotsRelease}_${speciesNickname}DoTS";
  my $fastalink1 = "$pipelineDir/blastSite/EPConDB_${speciesNickname}DoTS";

  mgr->runCmd("ln -s $outputFile1 $fastalink1");
  mgr->runCmd("$blastBinDir/xdformat -n $fastalink1");
  mgr->runCmd("rm -rf $fastalink1");
  mgr->runCmd("gzip $outputFile1");
  

  $mgr->endStep($signal) if $epconDB_makefile eq 'no';

  my $epconDB_chip = $propertySet->getProp('epconDB_chip');
  my $outputFile2  = "$pipelineDir/misc/${epconDB_chip}_rel${dotsRelease}_${speciesNickname}DoTS";
  my $fastalink2 = "$pipelineDir/blastSite/${epconDB_chip}_${speciesNickname}DoTS";

  $mgr->runCmd("ln -s $outputFile2 $fastalink2");
  $mgr->runCmd("$blastBinDir/xdformat -n $fastalink2");
  $mgr->runCmd("rm -rf $fastalink2");
  $mgr->runCmd("gzip $outputFile2");

  $mgr->endStep($signal);

}

sub prepareBlastSiteFiles {
    my $signal = "prepareBlastSiteFiles";

    return if $mgr->startStep("Preparing files for blast site", $signal);

    # make blast files for this species
    my $dotsRelease = $propertySet->getProp('dotsRelease');
    my $speciesNickname = $propertySet->getProp('speciesNickname');
    my $blastBinDir = $propertySet->getProp('wuBlastBinPath');

    my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";
    my $fastafile = "$pipelineDir/downloadSite/${prefix}.fasta.gz";
    my $cmd = " gunzip $pipelineDir/downloadSite/${prefix}.fasta.gz";
    $mgr->runCmd($cmd);
    $fastafile = "$pipelineDir/downloadSite/${prefix}.fasta";
    my $fastalink = "$pipelineDir/blastSite/${speciesNickname}DoTS";
    $mgr->runCmd("ln -s $fastafile $fastalink");
    $mgr->runCmd("$blastBinDir/xdformat -n $fastalink");

    # make blast files for all species.  combine this build w/ latest of other species
    my $dotsBuildDir = $propertySet->getProp('dotsBuildDir');
    my $otherSpeciesNickname = $speciesNickname eq 'mus'? 'hum' : 'mus';
    my $otherSpeciesRelease = $propertySet->getProp('otherSpeciesRelease');
    my $otherSpeciesBuildName = &makeBuildNameRls($otherSpeciesNickname, $otherSpeciesRelease);
    my $otherPipelineDir = "$dotsBuildDir/$otherSpeciesBuildName";
    my $prefix = "${otherSpeciesNickname}DoTS_rel${otherSpeciesRelease}";

    my $cmd = "gunzip $otherPipelineDir/downloadSite/${prefix}.fasta.gz";
    $mgr->runCmd($cmd);
    my $fastafile2 = "$otherPipelineDir/downloadSite/${prefix}.fasta";
    my $fastalink2 = "$pipelineDir/blastSite/${otherSpeciesNickname}DoTS";
    $mgr->runCmd("ln -s $fastafile2 $fastalink2");
    $mgr->runCmd("cat $fastalink $fastalink2 > $pipelineDir/blastSite/allDoTS");
    $mgr->runCmd("$blastBinDir/xdformat -n $pipelineDir/blastSite/allDoTS");
    $mgr->runCmd("gzip $fastafile2");
    $mgr->runCmd("rm -rf $fastalink2");
    $mgr->runCmd("rm -rf $pipelineDir/blastSite/allDoTS");


    $mgr->runCmd("rm -rf $fastalink");

    $mgr->runCmd("gzip $fastafile");

    $mgr->endStep($signal);

}

sub markBadSeqs {
    my $file = "$pipelineDir/repeatmask/assemSeqs/blocked.err";

    my $regex = "\\>(\\d+)";

    my $args = "--filename $file --processed_category repeat --regex_id \"$regex\"";

    $mgr->runPlugin("markBadSeqs", 
		    "DoTS::DotsBuild::Plugin::MarkAssemblySequencesBad", 
		    $args, 
		    "Marking bad assembly table sequences");
}


sub extractMarkers {
    my $signal = "extractMarkers";

    return if $mgr->startStep("Extracting Markers", $signal);

    my $taxonId = $propertySet->getProp('taxonId');

    my $markerFile = "$pipelineDir/epcr/rh.sts";

    my $cmd = "extractMarkers --taxon_id $taxonId --outputFile $markerFile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);

}

sub runEPCR {
    my $signal = "runEPCR";

    return if $mgr->startStep("Running e-PCR", $signal);

    my $ePCRinPath = $propertySet->getProp('ePCRinPath');

    my $seqFile = "$pipelineDir/seqfiles/finalDots.fsa";

    my $markersFile = "$pipelineDir/epcr/rh.sts";
    my $epcrFile = "$pipelineDir/epcr/finalDots.epcr";
    my $logFile = "$pipelineDir/logs/$signal.log";

    my $cmd = "$ePCRinPath/e-PCR $markersFile $seqFile > $epcrFile 2>> $logFile";
    
    $mgr->runCmd($cmd);

    $mgr->endStep($signal);

}

sub deleteEPCR {

    my $signal = "deleteEPCR";

    return if $mgr->startStep("Deleting EPCR from GUS", $signal);
    
    my $taxonId = $propertySet->getProp('taxonId');

    my $logFile = "$pipelineDir/logs/${signal}.log";

    my $sql = "select /*+ RULE */ e.epcr_id from dots.epcr e, dots.nasequenceimp n where n.taxon_id = $taxonId and e.na_sequence_id=n.na_sequence_id";

    my $cmd = "deleteEntries.pl --table DoTS::EPCR --idSQL \"$sql\" --verbose 2>> $logFile";
    
    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}


sub insertEPCR {
    my $signal = "insertEPCR";

    my $epcrFile = "$pipelineDir/epcr/finalDots.epcr";
    my $logFile = "$pipelineDir/logs/$signal.log";

    my $args = "--idcol string1 --file $epcrFile --dir $pipelineDir/plugins/$signal --log $logFile --maptableid 2782 --seqsubclassview Assembly";

    $mgr->runPlugin($signal, "DoTS::DotsBuild::Plugin::LoadEPCR", 
		    $args, "Inserting EPCR");
}

sub deleteAnatomyPercent {

    my $signal = "deleteAnatomyPercent";

    return if $mgr->startStep("Deleting AssemblyAnatomyPercent entries from GUS", $signal);
    
    my $taxonId = $propertySet->getProp('taxonId');

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $logFile = "$pipelineDir/logs/${signal}.log";

    my $sql = "select assembly_anatomy_percent_id from dots.assemblyanatomypercent where na_sequence_id in (select  na_sequence_id from dots.assembly where taxon_id = $taxonId)";

    my $cmd = "deleteEntries.pl --table DoTS::AssemblyAnatomyPercent --idSQL \"$sql\" --verbose 2>> $logFile";
    
    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub insertAnatomyPercent {
    
    my $taxonId = $propertySet->getProp('taxonId');

    my $idSQL = "select na_sequence_id from dots.Assembly where taxon_id = $taxonId";

    my $args = "--idSQL \"$idSQL\" --taxon_id $taxonId";

    $mgr->runPlugin("insertAnatomyPercent", 
		    "DoTS::DotsBuild::Plugin::AssignLibraryDistributionToAssemblies", 
		    $args, 
		    "mapping assemblies onto anatomy_id in AssemblyAnatomypercent");

} 


sub makeFrameFinder {

  ## MUST PASS THE PLUGIN THE FRAMEFINDER DIRECTORY!!!!!!!

    my $taxonId = $propertySet->getProp('taxonId');

    my $idSQL = "select na_sequence_id from dots.assembly where taxon_id = $taxonId";

    my $wordfile = $propertySet->getProp('wordfile'); 

    my $restart = $propertySet->getProp('frameFinderRestart');

    my $ffDir = $propertySet->getProp('frameFinderDir');
    my $dianaDir = $propertySet->getProp('dianaDir');

    my $args = "--wordfile $wordfile --restart $restart --ffdir $ffDir --dianadir $dianaDir --idSQL \"$idSQL\" ";

    $mgr->runPlugin("makeFramefinder", 
		    "DoTS::DotsBuild::Plugin::FrameFinder",
		    $args, "running FrameFinder plugin");
}

sub versionGeneTrapAssembly {

    my $signal = "versionGeneTrapAssembly";

    return if $mgr->startStep("Versioning entries from GeneTrapAssembly", $signal,'loadGeneTrapAssembly');

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $taxonId = $propertySet->getProp('taxonId');

    my $userId = $propertySet->getProp('userId');

    my $logFile = "$pipelineDir/logs/${signal}.log";

    my $sql = "select gene_trap_assembly_id from dots.genetrapassembly g, dots.assembly a where a.na_sequence_id=g.assembly_na_sequence_id and a.taxon_id=$taxonId";

    my $cmd = "versionEntries.pl --table DoTS.GeneTrapAssembly --idSQL \"$sql\" --tablePK 'gene_trap_assembly_id' --userId $userId --gusConfigFile $gusConfigFile --verbose 2>> $logFile";
    
    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub deleteGeneTrapAssembly {

    my $signal = "deleteGeneTrapAssembly";

    return if $mgr->startStep("Deleting entries from GeneTrapAssembly",
			      $signal, 'loadGeneTrapAssembly');

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $taxonId = $propertySet->getProp('taxonId');

    my $logFile = "$pipelineDir/logs/${signal}.log";

    my $sql = "select gene_trap_assembly_id from dots.genetrapassembly g, dots.assembly a where a.na_sequence_id=g.assembly_na_sequence_id and a.taxon_id=$taxonId";

    my $cmd = "deleteEntries.pl --table DoTS::GeneTrapAssembly --idSQL \"$sql\" --verbose 2>> $logFile";
    
    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
} 

sub insertBaygenomicsGeneTags {

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');
    
    my $downloadSubDir = "$externalDbDir/genetags/UC/$date";

    my $geneTagFile = "$downloadSubDir/baygenomics.fasta";

    my $logFile = "$pipelineDir/logs/baygenomics.log";

    my $geneTagDB = $propertySet->getProp('ucgt_db_rls_id');

    my $taxonId = $propertySet->getProp('taxonId');

    # >CT141 (Mus musculus, clone IMAGE:3983821, mRNA, partial cds 
    # >CT082 (Gtl7: gene trap locus 7)
    # >TEA122

    my $regex_src_id = "^\\>(\\w+)";  
    my $regex_desc = "^\\>\\w+\\s(.+)";

    my $args = "--verbose --table_name DoTS::ExternalNASequence --sequencefile $geneTagFile --external_database_release_id $geneTagDB --regex_source_id \"$regex_src_id\"  --regex_desc \"$regex_desc\" --taxon_id $taxonId";

    $mgr->runPlugin("insertBaygenomicsGeneTag", 
		    "GUS::Common::Plugin::InsertNewExternalSequences", $args,
		    "Inserting UC Gene Tags", 'NewGeneTags');
}

sub downloadGGTC {

  my $signal = "getGGTCSeqs";

  return if $mgr->startStep("Getting all GGTC files", $signal, 'NewGeneTags');

  my $externalDbDir = $propertySet->getProp('externalDbDir');

  my $date = $propertySet->getProp('buildDate');
    
  my $downloadSubDir = "$externalDbDir/genetags/GGTC/$date";

  my $logfile = "$pipelineDir/logs/${signal}.log";

  $mgr->runCmd("mkdir -p $downloadSubDir");

  my $cmd = "wget -t5 -b -m -np -nd -nH -o $logfile  --cut-dirs=2 -A \"*html\"  -P $downloadSubDir http://tikus.gsf.de/project/sequence/";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);

}

sub makeGGTCFastaFile {

  my $signal = "makeGGTCFastaFile";

  return if $mgr->startStep("Making GGTC fasta file", $signal, 'NewGeneTags');

  my $externalDbDir = $propertySet->getProp('externalDbDir');

  my $date = $propertySet->getProp('buildDate');
    
  my $sourceDir = "$externalDbDir/genetags/GGTC/$date";

  my $logfile = "$pipelineDir/logs/${signal}.log";

  my $fastaFile = "$sourceDir/ggtc.fsa";

  my $cmd = "makeFastaFile $sourceDir > $fastaFile 2>>  $logfile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);

}

sub insertGGTCGeneTags {

  my $externalDbDir = $propertySet->getProp('externalDbDir');
  
  my $date = $propertySet->getProp('buildDate');
  
  my $downloadSubDir = "$externalDbDir/genetags/GGTC/$date";
  
  my $geneTagFile = "$downloadSubDir/ggtc.fsa";
  
  my $logFile = "$pipelineDir/logs/insertGGTCGeneTag.log";
  
  my $geneTagDB = $propertySet->getProp('ggtc_db_rls_id');
  
  my $taxonId = $propertySet->getProp('taxonId');
  
  # >M022D07 - 01382
  # >W007A01 - 00001
  
  my $regex_src_id = "\\-\\s(\\d+)";  
  my $secondary_identifier = "^\\>(\\S+)";
  my $regex_desc = "^\\>(.*)";
  
  my $args = "--verbose --table_name DoTS::ExternalNASequence --sequencefile $geneTagFile --external_database_release_id $geneTagDB --regex_source_id \"$regex_src_id\"  --regex_secondary_id \"$secondary_identifier\" --regex_desc \"$regex_desc\" --taxon_id $taxonId";
  
  $mgr->runPlugin("insertGGTCGeneTag", 
		  "GUS::Common::Plugin::InsertNewExternalSequences", $args,
		  "Inserting GGTC Gene Tags", 'NewGeneTags');
}
 

sub extractGeneTrapTags {
  
  my $signal = "extractGeneTags";
  
  return if $mgr->startStep("Extracting gene trap tags from GUS", $signal, 'loadGeneTrapAssembly');
  
  my $gusConfigFile = $propertySet->getProp('gusConfigFile');
  
  my $taxonId = $propertySet->getProp('taxonId');

  my @DBs = split(/,/, $propertySet->getProp('geneTrapDbRls'));
  
  foreach my $db (@DBs) {
    my ($name, $id) = split(/:/, $db);
    my $seqFile = "$pipelineDir/genetrap/${name}.fsa";
    my $logFile = "$pipelineDir/logs/geneTrapTag${name}.log";
    
    my $sql = "select na_sequence_id,sequence from dots.ExternalNASequence where taxon_id = $taxonId and external_database_release_id = $id";
    
    my $cmd = "dumpSequencesFromTable.pl --outputFile $seqFile --verbose --gusConfigFile $gusConfigFile  --idSQL \"$sql\" 2>>  $logFile";
    
    $mgr->runCmd($cmd);
  }
  
  $mgr->endStep($signal);
}

sub blastGeneTrapTags {
  
  my $geneTagSource = @_;
  
  my $signal = "blastGeneTrapTags";
  
  return if $mgr->startStep("Blasting gene trap tags vs final mouse DoTS", $signal, 'loadGeneTrapAssembly');
  
  my $dotsFile = "$pipelineDir/blastSite/musDoTS";
  
  my $blastBinDir = $propertySet->getProp('wuBlastBinPath');
  
  my $blastn = "${blastBinDir}/blastn";
  
  my @DB = split (/,/, $propertySet->getProp('geneTrapDbRls'));
  
  foreach my $db (@DB) {
    
    my ($name, $id) = split(/:/, $db);
    
    my $tagFile = "$pipelineDir/genetrap/${name}.fsa";
    
    my $dotsRelease = $propertySet->getProp('dotsRelease');
    
    my $outputDir = "$pipelineDir/genetrap/$name";

    my $logFile = "$pipelineDir/logs/${name}Blast.log";
    
    my $mkdir = "mkdir $outputDir";
    
    $mgr->runCmd($mkdir);
    
    my $cmd = "blastAll.pl --blastn $blastn --seqfile $tagFile --musdots $dotsFile --targetdirlogin $outputDir 2>> $logFile";
    
    $mgr->runCmd($cmd);
  }
  
  $mgr->endStep($signal);
}

sub loadGeneTrapAssembly {
  
  my @DB = split (/,/, $propertySet->getProp('geneTrapDbRls'));
  
  foreach my $db (@DB) {
    my ($name, $id) = split(/:/, $db);
    my $blastDir = "$pipelineDir/genetrap/$name";
    my $args = "--external_db_release $id --blast_dir $blastDir";
    $mgr->runPlugin("load${name}GeneTrapBlast", "DoTS::DotsBuild::Plugin::CalculateGeneTrapLinks", $args, "loading blast results for $name gene trap tags",'loadGeneTrapAssembly');
  } 
}

sub assemblyProteinIntegration {

    my $taxonId = $propertySet->getProp('taxonId');

    my $args = "--taxon_id $taxonId";

    $mgr->runPlugin("integrateAssemblyProtein", "DoTS::DotsBuild::Plugin::AssemblyProteinInstance", $args, "integrating assemblies and proteins"); 
}

sub RNAProteinIntegration {

    my $taxonId = $propertySet->getProp('taxonId');

    my $sourceDB = $propertySet->getProp('sourceDB');

    my @DBs = split(/,/, $sourceDB);

    my @extRel;

    foreach my $db (@DBs) {
      my ($db_rel_id, $abrev) = split(/:/, $db);
      die "--sourceDB db_rel_id:abreviation pairs must be provided\n" if (!$db_rel_id || !$abrev);
      push (@extRel, $db_rel_id);
    }

    my $relList = join(',', @extRel);

    my $args = "--taxon_id $taxonId --ext_db_rel $relList";

    $mgr->runPlugin("integrateRNAProtein", "DoTS::DotsBuild::Plugin::RNAProteinIntegration", $args, "integrating RNA and proteins");
} 


sub makeGeneForRNA  {

  my $taxonId = $propertySet->getProp('taxonId');

  my $args = "--taxon $taxonId";

  $mgr->runPlugin("makeGeneForRNA", "DoTS::DotsBuild::Plugin::MakesGenesForRNA", $args, "making genes for rna with null gene_id");
} 
  

sub makeStatisticsPage {

  my $signal = "makeStatisticsPage";

  return if $mgr->startStep("Making statistics html file", $signal,'makeStatPage');

  my $output = "$pipelineDir/misc/statistics.html.in";

  my $logfile = "$pipelineDir/logs/${signal}.log";

  my $cmd = "dotsStatistics --templateFile $ENV{GUS_HOME}/data/DoTS/DotsBuild/statsTemplate.html.in --goRowTemplateFile $ENV{GUS_HOME}/data/DoTS/DotsBuild/statsGoRowTemplate.txt --goBarGraphWidth 200 > $output 2>> $logfile"; 

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);
}


sub downloadMGIInfo {

    my $signal = "downloadMGIInfo";

    return if $mgr->startStep("Downloading MGI Info", $signal,'loadMGI');

    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadMGIInfo.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');

    my $downloadSubDir = "$externalDbDir/mgi/$date";

    $mgr->runCmd("mkdir -p $downloadSubDir");
    
    my $cmd = "wget -t5 -o $logfile -b -m -np -nd -nH --cut-dirs=2 -A \"MRK_Dump2.rpt\"  -P $downloadSubDir  ftp://ftp.informatics.jax.org/pub/reports/";

    $mgr->runCmd($cmd) unless (-e "$downloadSubDir/MRK_Dump2.rpt");

    my $cmd = "wget -t5 -o $logfile -b -m -np -nd -nH --cut-dirs=3 -A \"MGI_DT_via_GB_one_*\"  -P $downloadSubDir  ftp://ftp.informatics.jax.org/pub/reports/dotstigr/";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
} 

sub deleteMGIToDots {
    
    my $signal = "deleteMGIToDots";

    return if $mgr->startStep("Deleting MGI to DoTS entries from DbRefNASequence", $signal,'loadMGI');

    my $mgiDbRlsId = $propertySet->getProp('mgi_db_rls_id');

    my $logFile = "$pipelineDir/logs/${signal}.log";

    my $sql = "select n.db_ref_na_sequence_id from sres.dbref d, dots.dbrefnasequence n where d.external_database_release_id = $mgiDbRlsId and d.db_ref_id = n.db_ref_id";

    my $cmd = "deleteEntries.pl --table DoTS::DbRefNASequence --idSQL \"$sql\" --verbose 2>> $logFile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);

}

sub loadMGIToDoTS {

  my $externalDbDir = $propertySet->getProp('externalDbDir');
  
  my $date = $propertySet->getProp('buildDate');
  
  my $downloadSubDir = "$externalDbDir/mgi/$date";

  my @file = split (/,/, $propertySet->getProp('mgiFiles'));
  
  my $files;
  
  foreach my $f (@file) {
    $files .= "$downloadSubDir/$f,";
  }

  chop($files);

  my $db_rel_id = $propertySet->getProp('mgi_db_rls_id');

  my $args = "--mappingfiles $files --delete --pattern1 '(MGI:\\d+)' --pattern2 'DT\.(\\d+)' --db_id 196 --db_rel_id $db_rel_id";
  
  $mgr->runPlugin("loadMGIMapping", "GUS::Common::Plugin::InsertDbRefAndDbRefNASequence", $args, "loading MGI to DoTS mapping",'loadMGI');
}

sub loadMGIInfo {

  my $externalDbDir = $propertySet->getProp('externalDbDir');

  my $date = $propertySet->getProp('buildDate');

  my $downloadSubDir = "$externalDbDir/mgi/$date";

  my $inputfile = "$downloadSubDir/MRK_Dump2.rpt";

  my $db_rel_id = $propertySet->getProp('mgi_db_rls_id');
  
  my $args = "--inputfile $inputfile --external_db_release_id $db_rel_id";
  
  $mgr->runPlugin("loadMGIInfo", "DoTS::DotsBuild::Plugin::LoadMGIInfo", $args, "Loading MGI Info",'loadMGI' );
  
}

sub deleteGeneCardsToDots {

    my $signal = "deleteGeneCardsToDots";

    return if $mgr->startStep("Deleting GeneCards to DoTS entries from DbRefNASequence", $signal,'loadGeneCards');

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $geneCardsDbRlsId = $propertySet->getProp('genecards_db_rls_id');

    my $logFile = "$pipelineDir/logs/${signal}.log";

    my $sql = "select n.db_ref_na_sequence_id from sres.dbref d, dots.dbrefnasequence n where d.external_database_release_id =$geneCardsDbRlsId and d.db_ref_id = n.db_ref_id";

    my $cmd = "deleteEntries.pl --table DoTS::DbRefNASequence --idSQL \"$sql\" --verbose 2>> $logFile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);

}

sub parseGeneCardsToDoTS {

  my $signal = "parseGeneCardsToDots";

  return if $mgr->startStep("Parsing GeneCards to DoTS entries from file", $signal,'loadGeneCards');

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $externalDbDir = $propertySet->getProp('externalDbDir');

  my $date = $propertySet->getProp('buildDate');

  my $downloadSubDir = "$externalDbDir/genecards/$date";

  my $inputfile = "$downloadSubDir/dumpForDots.txt";

  my $outputfile = "$downloadSubDir/geneCards2DoTS.txt";

  my $cmd = "DoTS2GeneCardsParse --inputFile $inputfile --outputFile $outputfile 2>>$logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);
}
    
sub loadGeneCardsToDoTS {

  my $externalDbDir = $propertySet->getProp('externalDbDir');
  
  my $date = $propertySet->getProp('buildDate');
  
  my $downloadSubDir = "$externalDbDir/genecards/$date";

  my $file = "$downloadSubDir/geneCards2DoTS.txt";

  my $geneCardsDbRlsId = $propertySet->getProp('genecards_db_rls_id');

  my $args = "--mappingfiles $file --delete --pattern1 '(\\S+)\\t' --pattern2 '\\tDT\.(\\d+)' --db_id 195 --db_rel_id $geneCardsDbRlsId";
  
  $mgr->runPlugin("loadGeneCardsMapping", "GUS::Common::Plugin::InsertDbRefAndDbRefNASequence", $args, "loading GeneCards to DoTS mapping",'loadGeneCards');
}

sub deleteGEAToDoTS {

    my $signal = "deleteGEAToDoTS";

    return if $mgr->startStep("Deleting GEA to DoTS entries from DbRefNASequence", $signal);

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $geaDbRlsId = $propertySet->getProp('gea_db_rls_id');

    my $logFile = "$pipelineDir/logs/${signal}.log";

    my $sql = "select n.db_ref_na_sequence_id from sres.dbref d, dots.dbrefnasequence n where d.external_database_release_id = $geaDbRlsId and d.db_ref_id = n.db_ref_id";

    my $cmd = "deleteEntries.pl --table DoTS::DbRefNASequence --idSQL \"$sql\" --gusConfigFile $gusConfigFile --verbose 2>> $logFile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);

}

sub parseGEA {

  my $signal = "parseGEAToDots";

  return if $mgr->startStep("Parsing GEA to DoTS entries from file", $signal);

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $externalDbDir = $propertySet->getProp('externalDbDir');

  my $downloadSubDir = "$externalDbDir/gea";

  my $geaFile = $propertySet->getProp('geaFile');

  my $inputfile = "$downloadSubDir/$geaFile";
  
  my $species = $propertySet->getProp('speciesNickname');

  my $outputfile = "$pipelineDir/misc/${species}gea2DoTS.txt";

  my $taxonId = $propertySet->getProp('taxonId');

  my $cmd = "makeGEA2DoTSfile --inputFile $inputfile --taxon_id $taxonId > $outputfile 2>>$logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);
}
    
sub loadGEA {

  my $externalDbDir = $propertySet->getProp('externalDbDir');
  
  my $downloadSubDir = "$externalDbDir/gea";

  my $species = $propertySet->getProp('speciesNickname');

  my $file = "$pipelineDir/misc/${species}gea2DoTS.txt";

  my $geaDbRlsId = $propertySet->getProp('gea_db_rls_id');

  my $geaDbId = $propertySet->getProp('gea_db_id');

  my $args = "--mappingfiles $file --pattern1 '(\\S+)\\t' --pattern2 '\\tDT\.(\\d+)' --db_id $geaDbId --db_rel_id $geaDbRlsId";
  
  $mgr->runPlugin("loadGEAMapping", "GUS::Common::Plugin::InsertDbRefAndDbRefNASequence", $args, "loading GEA to DoTS mapping");
}

sub downloadLocusLink {

    my $signal = "downloadLocusLink";

    return if $mgr->startStep("Downloading LocusLink", $signal,'downloadLocusLink');

    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadLocusLink.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');

    my $downloadSubDir = "$externalDbDir/locuslink/$date";

    $mgr->runCmd("mkdir -p $downloadSubDir");
    
    my $cmd = "wget -t5 -o $logfile -b -m -np -nd -nH --cut-dirs=2 -A \"loc2acc,loc2ref\"  -P $downloadSubDir  ftp://ftp.ncbi.nlm.nih.gov/refseq/LocusLink/";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
} 

sub deleteLocusLink {

    my $signal = "deleteLocusLinkToDots";

    return if $mgr->startStep("Deleting LocusLink to DoTS entries from DbRefNASequence", $signal);

    my $taxonId = $propertySet->getProp('taxonId');

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $llDbRlsId = $propertySet->getProp('locuslink_db_rls_id');

    my $logFile = "$pipelineDir/logs/${signal}.log";

    my $sql = "select n.db_ref_na_sequence_id from sres.dbref d, dots.dbrefnasequence n, dots.assembly a where d.external_database_release_id = $llDbRlsId and d.db_ref_id = n.db_ref_id and n.na_sequence_id = a.na_sequence_id and a.taxon_id = $taxonId";

    my $cmd = "deleteEntries.pl --table DoTS::DbRefNASequence --idSQL \"$sql\" --verbose 2>> $logFile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);

}

sub parseLocusLink {

  my $signal = "parseLocusLinkToDoTS";

  return if $mgr->startStep("Parsing LocusLink to DoTS entries from file", $signal);

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $externalDbDir = $propertySet->getProp('externalDbDir');

  my $date = $propertySet->getProp('buildDate');

  my $downloadSubDir = "$externalDbDir/locuslink/$date";

  my $inputfile_acc = "$downloadSubDir/loc2acc";
  
  my $species = $propertySet->getProp('speciesNickname');

  my $outputfile_acc = "$pipelineDir/misc/${species}LL2DoTSacc";

  my $taxonId = $propertySet->getProp('taxonId');

  my $tax_id = $propertySet->getProp('ncbiTaxId');

  #my $cmd = "makeLL2DoTSfile --inputFile $inputfile_acc --taxon_id $taxonId --tax_id $tax_id > $outputfile_acc 2>>$logFile";

  #$mgr->runCmd($cmd);

  my $inputfile_ref = "$downloadSubDir/loc2ref";

  my $outputfile_ref = "$pipelineDir/misc/${species}LL2DoTSref";

  my $cmd = "makeLLRef2DoTSfile --inputFile $inputfile_ref --taxon_id $taxonId --tax_id $tax_id > $outputfile_ref 2>>$logFile";

  $mgr->runCmd($cmd);

  my $outputfile_pre = "$pipelineDir/misc/${species}LL2DoTSpre";

  $cmd = "cat $outputfile_acc $outputfile_ref > $outputfile_pre";

  $mgr->runCmd($cmd);

  my $outputfile_sort = "$pipelineDir/misc/${species}LL2DoTSsort";

  $mgr->runCmd("sort $outputfile_pre >$outputfile_sort");

  my $outputfile = "$pipelineDir/misc/${species}LL2DoTS";

  $mgr->runCmd("uniq $outputfile_sort >$outputfile");

  $cmd = "cp $outputfile $pipelineDir/downloadSite";

  $mgr->runCmd($cmd);
  
  my $dotsRelease = $propertySet->getProp('dotsRelease');

  $cmd = "mv $pipelineDir/downloadSite/${species}LL2DoTS $pipelineDir/downloadSite/${species}DoTS_rel${dotsRelease}_LL2DoTS";

  $mgr->runCmd($cmd);

  $cmd = "gzip $pipelineDir/downloadSite/${species}DoTS_rel${dotsRelease}_LL2DoTS";

  $mgr->runCmd($cmd);

  &updateHtaccessFile("AddDescription \"A mapping of DoTS to LocusLink\" *LL*\n");

  $mgr->endStep($signal);
}

sub loadLocusLinkToDoTS {

  my $signal = "loadLocusLinkToDoTS";

  return if $mgr->startStep("Inserting LocusLink to DoTS entries from file", $signal);

  my $species = $propertySet->getProp('speciesNickname');

  my $file = "$pipelineDir/misc/${species}LL2DoTS";

  my $llDbRlsId = $propertySet->getProp('locuslink_db_rls_id');

  my $llDbId = $propertySet->getProp('ll_db_id');

  my $llDeleteDbRef = $propertySet->getProp('llDeleteDbRef');

  my $delete = $llDeleteDbRef eq "yes" ? "--delete" : "";

  my $args = "--mappingfiles $file $delete --pattern1 '\\s+(\\d+)' --pattern2 'DT\.(\\d+)' --db_id $llDbId --db_rel_id $llDbRlsId";
  
  $mgr->runPlugin("loadLLmapping", "GUS::Common::Plugin::InsertDbRefAndDbRefNASequence", $args, "loading LL to DoTS mapping");
}

sub makeProjectLink {

    my $signal = "makeProjectLink";

    return if $mgr->startStep("Insert links between projectinfo and nasequence into projectlink table", $signal);

    my $taxonId = $propertySet->getProp('taxonId');

    my $allgenesVer = $propertySet->getProp('allgenesVersion');
    
    my $project_id = $propertySet->getProp('project_id');
    
    my $logFile = "$pipelineDir/logs/${signal}.log";

    my $args;

    my $project = $project_id > 0 ? "--project_id ".$project_id : "";
    $args = "--commit --verbose --allgenes_num $allgenesVer --taxon $taxonId $project";

    $args .= " --restart"
      if ($propertySet->getProp('projectLinkRestart') eq "yes");

    my $cmd = "makeProjectLink.pl $args 2>> $logFile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub updateProteinAssemblyTable {
  
  my $signal = "updateProteinAssemblyTable";

  return if $mgr->startStep("Insert entries in allgenes ProteinAssembly table ", $signal);

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $taxonId = $propertySet->getProp('taxonId');

  my $allgenesSchema = $propertySet->getProp('allgenesSchema');

  my $args = "--verbose --taxon $taxonId --allgenesSchema $allgenesSchema";

  my $cmd = "updateProteinAssemblyTable $args 2>> $logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);


}

sub updateDTOrfPValueTable {

  my $signal = "updateDTOrfPValueTable";

  return if $mgr->startStep("Insert entries in allgenes makeDTOrfPValue table", $signal);

  my $taxonId = $propertySet->getProp('taxonId');

  my $allgenesSchema = $propertySet->getProp('allgenesSchema');

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $args = "--verbose --taxon $taxonId --allgenesSchema $allgenesSchema";

  my $cmd = "updateDTOrfPvalueTable $args 2>> $logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);

}

sub updatePromoterRegionTable {

  my $signal = "updatePromoterRegionTable";

  return if $mgr->startStep("Insert entries into Allgenes.PromoterRegion table", $signal);

  my $taxonId = $propertySet->getProp('taxonId');

  my $allgenesSchema = $propertySet->getProp('allgenesSchema');

  my $genome_rls_id = $propertySet->getProp('genome_db_rls_id');

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $args = "--taxon $taxonId --genomeExtRelDbId $genome_rls_id --allgenesSchema $allgenesSchema";

  my $cmd = "updatePromoterRegionTable $args 2>> $logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);

}

sub updatePancreasAssembliesTable {

  my $signal = "updatePancreasAssembliesTable";

  return if $mgr->startStep("Insert entries in Allgenes.PancreasAssemblies table", $signal);

  my $taxonId = $propertySet->getProp('taxonId');

  my $allgenesSchema = $propertySet->getProp('allgenesSchema');

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $args = "--verbose --taxon $taxonId --allgenesSchema $allgenesSchema";

  my $cmd = "updatePancreasAssembliesTable $args 2>> $logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);

}

sub updateAssemblySignalPSummaryTable {

  my $signal = "updateAssemblySignalPSummaryTable";

  return if $mgr->startStep("Insert entries in allgenes makeAssemblySignalPSummary table", $signal);

  my $taxonId = $propertySet->getProp('taxonId');

  my $allgenesSchema = $propertySet->getProp('allgenesSchema');

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $args = "--verbose --taxon $taxonId --allgenesSchema $allgenesSchema";

  my $cmd = "updateAssemblySignalPSummaryTable $args 2>> $logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);

}

sub updateAssemblyTMDomainSummaryTable {

  my $signal = "updateAssemblyTMDomainSummaryTable";

  return if $mgr->startStep("Insert entries in allgenes makeAssemblyTMDomainSummary table", $signal);

  my $taxonId = $propertySet->getProp('taxonId');

  my $allgenesSchema = $propertySet->getProp('allgenesSchema');

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $args = "--verbose --taxon $taxonId --allgenesSchema $allgenesSchema";

  my $cmd = "updateAssemblyTMDomainSummaryTable $args 2>> $logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);

}

sub makePredictedProteinFile {


  my $signal = "makePredictedProteinFile";
  
  return if $mgr->startStep("Prepar predicted protein file", $signal);
  
  my $dotsRelease = $propertySet->getProp('dotsRelease');
  my $speciesNickname = $propertySet->getProp('speciesNickname');
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";
  my $predictedProteinsFile = "${prefix}_predictedProteins.fasta";

  my $taxonId = $propertySet->getProp('taxonId');

  my $gusConfigFile = $propertySet->getProp('gusConfigFile');

  my $logFile = "$pipelineDir/logs/${predictedProteinsFile}Extract.log";
  
  my $sql = "select 'DT.'||a.na_sequence_id,'length of predicted protein sequence ='||ts.length,ts.sequence from dots.translatedaasequence ts,dots.translatedaafeature tf,dots.rnafeature rf,dots.assembly a where a.taxon_id = $taxonId and a.na_sequence_id = rf.na_sequence_id and rf.na_feature_id = tf.na_feature_id and tf.aa_sequence_id = ts.aa_sequence_id";
  
  my $cmd = "dumpSequencesFromTable.pl --outputFile $pipelineDir/seqfiles/$predictedProteinsFile --verbose --gusConfigFile $gusConfigFile  --idSQL \"$sql\" 2>>  $logFile";
  
  $mgr->runCmd($cmd);
  
  $mgr->endStep($signal);

}

sub makeProteinChunks {

  my $signal = "makeProteinChunks";

  return if $mgr->startStep("dividing up the protein sequences", $signal);

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $speciesNickname = $propertySet->getProp('speciesNickname');
  
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  my $predictedProteinsFile = "$pipelineDir/seqfiles/${prefix}_predictedProteins.fasta";

  my $proteinChunkDir = "$pipelineDir/misc/proteinSequenceChunks";

  my $cmd = "mkdir $proteinChunkDir";

  $mgr->runCmd($cmd);

  my $cmd ="fasplit --InputFile $predictedProteinsFile --ChunkSize 1000 --OutputFileFormat ${proteinChunkDir}/%04.04d.fa";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);
}


sub predictTmAndSignalP {

  my $signal = "predictTmAndSignalP";

  return if $mgr->startStep("making TM and signalP predictions", $signal);

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $speciesNickname = $propertySet->getProp('speciesNickname');
  
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  my $predictedProteinsFile = "$pipelineDir/seqfiles/${prefix}_predictedProteins.fasta";

  my $outputfile = "$pipelineDir/misc/${prefix}_predictedProteins";

  my $proteinChunkDir = "$pipelineDir/misc/proteinSequenceChunks";

  my $cmd = "all-predictions $predictedProteinsFile $outputfile $proteinChunkDir 2>>$logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);

}


sub parseTMFile {

  my $signal = "parseTMFile";

  return if $mgr->startStep("parsing the TM prediction file", $signal);

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $predictionPath = "$pipelineDir/misc/*.tmhmm.*";

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $speciesNickname = $propertySet->getProp('speciesNickname');
  
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  my $outputFile = "$pipelineDir/misc/${prefix}_predictedProteins.tmhmm.parsed";

  my $predictedProteinsFile = "$pipelineDir/seqfiles/${prefix}_predictedProteins.fasta";

  my $type = 'tmhmm';

  my $cmd = " parse-predictions --PredictionPath $predictionPath --AaSequenceFile $predictedProteinsFile --Type $type > $outputFile 2>>$logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);
}

sub parseSGPSignalP {

  my $signal = "parseSGPSignalPFile";

  return if $mgr->startStep("parsing the signalP SGP prediction files", $signal);

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $predictionPath = "$pipelineDir/misc/proteinSequenceChunks/*.fa.sgp.Z";

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $speciesNickname = $propertySet->getProp('speciesNickname');
  
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  my $outputFile = "$pipelineDir/misc/proteinSequenceChunks/${prefix}_predictedProteins.sgp.parsed";

  my $predictedProteinsFile = "$pipelineDir/seqfiles/${prefix}_predictedProteins.fasta";

  my $type = 'sgp';

  my $cmd = " parse-predictions --PredictionPath \"$predictionPath\" --AaSequenceFile $predictedProteinsFile --Type $type > $outputFile 2>>$logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);
}
 
sub parseSGPHMMSignalP {

  my $signal = "parseSGPHMMSignalPFile";

  return if $mgr->startStep("parsing the signalP SGPHMM prediction files", $signal);

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $predictionPath = "$pipelineDir/misc/proteinSequenceChunks/*.fa.sgphmm.Z";

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $speciesNickname = $propertySet->getProp('speciesNickname');

  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  my $outputFile = "$pipelineDir/misc/proteinSequenceChunks/${prefix}_predictedProteins.sgphmm.parsed";

  my $predictedProteinsFile = "$pipelineDir/seqfiles/${prefix}_predictedProteins.fasta";

  my $type = 'sgphmm';

  my $cmd = " parse-predictions --PredictionPath \"$predictionPath\" --AaSequenceFile $predictedProteinsFile --Type $type > $outputFile 2>>$logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);
}

sub deletePredictedAAFeatures{

  my ($predictionTable) = @_;

  my $signal = "delete${predictionTable}";

  return if $mgr->startStep("Deleting predicted TM features from GUS", $signal);

  my $logFile = "$pipelineDir/logs/$signal.log";

  my $taxonId = $propertySet->getProp('taxonId');

  my $sql = "select p.aa_feature_id from dots.${predictionTable} p, dots.translatedaafeature f, dots.rnafeature r, dots.assembly a where a.taxon_id = $taxonId and a.na_sequence_id = r.na_sequence_id and r.na_feature_id = f.na_feature_id and f.aa_sequence_id = p.aa_sequence_id";

  my $cmd = "deleteAAFeatures.pl --table DoTS::${predictionTable} --idSQL \"$sql\" 2>> $logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);
}

sub loadTMHMM {

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $speciesNickname = $propertySet->getProp('speciesNickname');
  
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  my $inputFile = "$pipelineDir/misc/${prefix}_predictedProteins.tmhmm.parsed";

  my $project_id = $propertySet->getProp('project_id');

  my $args = "--filename $inputFile --project_id $project_id";

  $mgr->runPlugin("loadTMHMM", "DoTS::DotsBuild::Plugin::LoadPredictedAAFeatures", $args, "loading parsed TMHMM predictions into GUS");

}


sub loadSGPSignalP {

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $speciesNickname = $propertySet->getProp('speciesNickname');
  
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  my $inputFile = "$pipelineDir/misc/proteinSequenceChunks/${prefix}_predictedProteins.sgp.parsed";

  my $project_id = $propertySet->getProp('project_id');

  my $args = "--filename $inputFile --project_id $project_id";

  $mgr->runPlugin("loadSGPSignalP", "DoTS::DotsBuild::Plugin::LoadPredictedAAFeatures", $args, "loading parsed SignalP predictions into GUS");
}

sub loadSGPHMMSignalP {

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $speciesNickname = $propertySet->getProp('speciesNickname');
  
  my $prefix = "${speciesNickname}DoTS_rel${dotsRelease}";

  my $inputFile = "$pipelineDir/misc/proteinSequenceChunks/${prefix}_predictedProteins.sgphmm.parsed";

  my $project_id = $propertySet->getProp('project_id');

  my $args = "--filename $inputFile --project_id $project_id";
  
  $mgr->runPlugin("loadSGPHMMSignalP", "DoTS::DotsBuild::Plugin::LoadPredictedAAFeatures", $args, "loading parsed SignalPHMM predictions into GUS");
}


sub cleanUpFiles {

  my $signal = "cleanUpFiles";

  return if $mgr->startStep("Cleaning up files", $signal);

  my $dotsRelease = $propertySet->getProp('dotsRelease');

  my $logFile = "$pipelineDir/logs/${signal}.log";

  my $cmd = "cleanReleaseDirs --currentRelease $dotsRelease --buildDir $pipelineDir 2>>$logFile";

  $mgr->runCmd($cmd);

  $mgr->endStep($signal);
}


sub makeBuildName {
  my ($nickName) = @_;

  return makeBuildNameRls($nickName, $propertySet->getProp('dotsRelease'));
}

sub makeBuildNameRls {
  my ($nickName, $release) = @_;

  return "release${release}/" . $nickName;
}

sub usage {
    print STDERR "usage:  dotsbuild propertiesfile\n";
    exit 1;
}



